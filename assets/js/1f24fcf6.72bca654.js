"use strict";(self.webpackChunk_inversifyjs_inversify_docs_site=self.webpackChunk_inversifyjs_inversify_docs_site||[]).push([["7130"],{8957:function(e,n,r){r.r(n),r.d(n,{frontMatter:()=>l,toc:()=>p,default:()=>h,metadata:()=>i,assets:()=>d,contentTitle:()=>c});var i=JSON.parse('{"id":"ecosystem/strongly-typed","title":"Strongly Typed Container","description":"The @inversifyjs/strongly-typed package adds TypeScript type definitions that bring compile-time type safety to your InversifyJS Container and @inject() decorators. With this package, you define a binding map that serves as a contract for your container, ensuring that bindings, retrievals, and injections are all type-checked at compile time.","source":"@site/versioned_docs/version-7.x/ecosystem/strongly-typed.mdx","sourceDirName":"ecosystem","slug":"/ecosystem/strongly-typed","permalink":"/docs/ecosystem/strongly-typed","draft":false,"unlisted":false,"tags":[],"version":"7.x","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Strongly Typed Container"},"sidebar":"tutorialSidebar","previous":{"title":"Framework","permalink":"/docs/ecosystem/framework"}}'),t=r(6820),a=r(7588),o=r(9274),s=r(9979);let l={sidebar_position:3,title:"Strongly Typed Container"},c="Strongly Typed Container",d={},p=[{value:"When to use it",id:"when-to-use-it",level:2},{value:"Key features",id:"key-features",level:2},{value:"Type-safe bindings",id:"type-safe-bindings",level:3},{value:"Type-safe retrieval",id:"type-safe-retrieval",level:3},{value:"Type-safe injection",id:"type-safe-injection",level:3},{value:"Promise support",id:"promise-support",level:3},{value:"Zero runtime overhead",id:"zero-runtime-overhead",level:3},{value:"Flexible usage",id:"flexible-usage",level:3},{value:"Installation",id:"installation",level:2},{value:"Quick start",id:"quick-start",level:2},{value:"Define your binding map",id:"define-your-binding-map",level:3},{value:"Create a typed container",id:"create-a-typed-container",level:3},{value:"Type-safe bindings",id:"type-safe-bindings-1",level:3},{value:"Type-safe retrieval",id:"type-safe-retrieval-1",level:3},{value:"Strongly-typed injection",id:"strongly-typed-injection",level:2},{value:"Constructor injection",id:"constructor-injection",level:3},{value:"Property injection",id:"property-injection",level:3},{value:"Advanced usage",id:"advanced-usage",level:2},{value:"Promise bindings",id:"promise-bindings",level:3},{value:"Container hierarchies",id:"container-hierarchies",level:3},{value:"Container modules",id:"container-modules",level:3},{value:"Known limitations",id:"known-limitations",level:2},{value:"Private properties",id:"private-properties",level:3},{value:"Constructor error messages",id:"constructor-error-messages",level:3},{value:"Benefits",id:"benefits",level:2},{value:"Earlier error detection",id:"earlier-error-detection",level:3},{value:"Better IDE support",id:"better-ide-support",level:3},{value:"Self-documenting",id:"self-documenting",level:3},{value:"Refactoring safety",id:"refactoring-safety",level:3},{value:"Zero runtime cost",id:"zero-runtime-cost",level:3},{value:"Package information",id:"package-information",level:2}];function u(e){let n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"strongly-typed-container",children:"Strongly Typed Container"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"@inversifyjs/strongly-typed"})," package adds TypeScript type definitions that bring compile-time type safety to your InversifyJS Container and ",(0,t.jsx)(n.code,{children:"@inject()"})," decorators. With this package, you define a binding map that serves as a contract for your container, ensuring that bindings, retrievals, and injections are all type-checked at compile time."]}),"\n",(0,t.jsx)(n.h2,{id:"when-to-use-it",children:"When to use it"}),"\n",(0,t.jsx)(n.p,{children:"Use the strongly-typed container when you want to catch binding and injection errors at compile time instead of runtime. You'll get IDE autocomplete for service identifiers and ensure type safety across your entire dependency injection setup. The binding map serves as living documentation of available services and prevents accidental injection of wrong types."}),"\n",(0,t.jsx)(n.p,{children:"If you prefer maximum flexibility or are working with highly dynamic binding scenarios, the standard container may be more appropriate."}),"\n",(0,t.jsx)(n.h2,{id:"key-features",children:"Key features"}),"\n",(0,t.jsx)(n.h3,{id:"type-safe-bindings",children:"Type-safe bindings"}),"\n",(0,t.jsx)(n.p,{children:"Bind services with compile-time validation that ensures you're registering the correct types for each service identifier."}),"\n",(0,t.jsx)(n.h3,{id:"type-safe-retrieval",children:"Type-safe retrieval"}),"\n",(0,t.jsx)(n.p,{children:"Get services with automatic type inference so your IDE knows exactly what type you're working with."}),"\n",(0,t.jsx)(n.h3,{id:"type-safe-injection",children:"Type-safe injection"}),"\n",(0,t.jsxs)(n.p,{children:["Use strongly-typed ",(0,t.jsx)(n.code,{children:"@inject()"})," decorators for constructor and property injection that verify the injected type matches the parameter or property type."]}),"\n",(0,t.jsx)(n.h3,{id:"promise-support",children:"Promise support"}),"\n",(0,t.jsx)(n.p,{children:"Distinguish between sync and async bindings at the type level, ensuring you use the correct retrieval method."}),"\n",(0,t.jsx)(n.h3,{id:"zero-runtime-overhead",children:"Zero runtime overhead"}),"\n",(0,t.jsx)(n.p,{children:"All type checking happens at compile time, so there's no performance penalty in production."}),"\n",(0,t.jsx)(n.h3,{id:"flexible-usage",children:"Flexible usage"}),"\n",(0,t.jsx)(n.p,{children:"Can be used as a direct import or as type assertions to keep the library out of your final dependency tree."}),"\n",(0,t.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,t.jsxs)(o.A,{children:[(0,t.jsx)(s.A,{value:"npm",label:"npm",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"npm install @inversifyjs/strongly-typed\n"})})}),(0,t.jsx)(s.A,{value:"pnpm",label:"pnpm",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"pnpm add @inversifyjs/strongly-typed\n"})})}),(0,t.jsx)(s.A,{value:"yarn",label:"yarn",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"yarn add @inversifyjs/strongly-typed\n"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"quick-start",children:"Quick start"}),"\n",(0,t.jsx)(n.h3,{id:"define-your-binding-map",children:"Define your binding map"}),"\n",(0,t.jsx)(n.p,{children:"Start by defining a binding map that describes all the services your container will provide:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"interface Foo {\n  foo: string;\n}\n\ninterface Bar {\n  bar: string;\n}\n\ninterface BindingMap {\n  foo: Foo;\n  bar: Bar;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"create-a-typed-container",children:"Create a typed container"}),"\n",(0,t.jsxs)(n.p,{children:["You can instantiate a ",(0,t.jsx)(n.code,{children:"TypedContainer"})," directly:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { TypedContainer } from '@inversifyjs/strongly-typed';\n\nconst container = new TypedContainer<BindingMap>();\n"})}),"\n",(0,t.jsx)(n.p,{children:"Or use type assertions to keep the library out of your dependency tree:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { Container } from 'inversify';\nimport type { TypedContainer } from '@inversifyjs/strongly-typed';\n\nconst container = new Container() as TypedContainer<BindingMap>;\n"})}),"\n",(0,t.jsx)(n.h3,{id:"type-safe-bindings-1",children:"Type-safe bindings"}),"\n",(0,t.jsx)(n.p,{children:"All bindings are now type-checked:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Valid - correct type\ncontainer.bind('foo').toConstantValue({ foo: 'abc' });\n\n// \u274C Compilation error - wrong type\ncontainer.rebind('foo').toConstantValue({ unknown: 'uh-oh' });\n\n// \u274C Compilation error - unknown identifier\ncontainer.bind('unknown').toConstantValue({ foo: 'xyz' });\n"})}),"\n",(0,t.jsx)(n.h3,{id:"type-safe-retrieval-1",children:"Type-safe retrieval"}),"\n",(0,t.jsx)(n.p,{children:"Service retrieval is fully type-checked with automatic type inference:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Valid - inferred type is Foo\nconst foo = container.get('foo');\n\n// \u274C Compilation error - bar is not assignable to Foo\nconst wrongType: Foo = container.get('bar');\n\n// \u274C Compilation error - unknown identifier\nconst invalid = container.get('unknown-identifier');\n"})}),"\n",(0,t.jsx)(n.h2,{id:"strongly-typed-injection",children:"Strongly-typed injection"}),"\n",(0,t.jsxs)(n.p,{children:["To use strongly-typed decorators, re-export the ",(0,t.jsx)(n.code,{children:"inject"})," and ",(0,t.jsx)(n.code,{children:"multiInject"})," decorators with type assertions:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { inject, multiInject } from 'inversify';\nimport type { TypedInject, TypedMultiInject } from '@inversifyjs/strongly-typed';\n\nexport const $inject = inject as TypedInject<BindingMap>;\nexport const $multiInject = multiInject as TypedMultiInject<BindingMap>;\n"})}),"\n",(0,t.jsx)(n.h3,{id:"constructor-injection",children:"Constructor injection"}),"\n",(0,t.jsx)(n.p,{children:"Use the typed decorator for constructor parameters:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { injectable } from 'inversify';\n\n@injectable()\nclass MyService {\n  constructor(\n    @$inject('foo') // \u2705 Valid\n    foo: Foo,\n\n    @$inject('foo') // \u274C Compilation error - foo is not assignable to Bar\n    bar: Bar,\n  ) {}\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"property-injection",children:"Property injection"}),"\n",(0,t.jsxs)(n.p,{children:["Property injection works for ",(0,t.jsx)(n.strong,{children:"public"})," properties:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@injectable()\nclass MyService {\n  @$inject('foo') // \u2705 Valid\n  public foo: Foo;\n\n  @$inject('foo') // \u274C Compilation error - wrong type\n  public bar: Bar;\n}\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Private properties cannot be strongly typed due to TypeScript decorator limitations. Use public properties (optionally prefixed with underscore) or fall back to the regular ",(0,t.jsx)(n.code,{children:"@inject()"})," decorator for private properties."]})}),"\n",(0,t.jsx)(n.h2,{id:"advanced-usage",children:"Advanced usage"}),"\n",(0,t.jsx)(n.h3,{id:"promise-bindings",children:"Promise bindings"}),"\n",(0,t.jsxs)(n.p,{children:["InversifyJS allows binding Promises, but they must be retrieved using ",(0,t.jsx)(n.code,{children:"getAsync()"}),". The type system enforces this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"interface BindingMap {\n  number: number;\n  asyncNumber: Promise<number>;\n}\n\nconst container = new TypedContainer<BindingMap>();\n\n// \u2705 Valid - sync binding with sync method\nconst num = container.get('number'); // number\n\n// \u274C Compilation error - can't use get() for Promise bindings\nconst asyncNum = container.get('asyncNumber');\n\n// \u2705 Valid - async binding with async method\nconst asyncNumCorrect = await container.getAsync('asyncNumber'); // number\n"})}),"\n",(0,t.jsx)(n.h3,{id:"container-hierarchies",children:"Container hierarchies"}),"\n",(0,t.jsx)(n.p,{children:"When creating child containers with parents, manually merge the binding maps:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"type ParentMap = {\n  parentService: ParentService;\n};\n\ntype ChildMap = {\n  childService: ChildService;\n};\n\nconst parent = new TypedContainer<ParentMap>();\nconst child = new TypedContainer<ParentMap & ChildMap>({ parent });\n\n// Child can access both parent and child bindings\nconst parentSvc = child.get('parentService');\nconst childSvc = child.get('childService');\n"})}),"\n",(0,t.jsx)(n.h3,{id:"container-modules",children:"Container modules"}),"\n",(0,t.jsx)(n.p,{children:"Create strongly-typed container modules:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { TypedContainerModule } from '@inversifyjs/strongly-typed';\n\nconst myModule = new TypedContainerModule<BindingMap>(\n  (bind) => {\n    bind('foo').toConstantValue({ foo: 'value' });\n    bind('bar').toConstantValue({ bar: 'value' });\n  }\n);\n\nawait container.load(myModule);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"known-limitations",children:"Known limitations"}),"\n",(0,t.jsx)(n.h3,{id:"private-properties",children:"Private properties"}),"\n",(0,t.jsx)(n.p,{children:"Due to TypeScript decorator limitations, private properties cannot be strongly typed with injection decorators:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@injectable()\nclass MyService {\n  @$inject('foo')\n  private foo: Foo; // \u274C Compilation error\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["You can work around this by making the property public (consider using an underscore prefix as a convention like ",(0,t.jsx)(n.code,{children:"public _foo"}),") or by using the regular ",(0,t.jsx)(n.code,{children:"@inject()"})," decorator from ",(0,t.jsx)(n.code,{children:"inversify"})," for private properties."]}),"\n",(0,t.jsx)(n.h3,{id:"constructor-error-messages",children:"Constructor error messages"}),"\n",(0,t.jsx)(n.p,{children:"When constructor injection types are incorrect, TypeScript produces generic error messages like:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Unable to resolve signature of parameter decorator when called as an expression.\n  Argument of type '2' is not assignable to parameter of type 'undefined'.\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This indicates that the constructor parameter at index ",(0,t.jsx)(n.code,{children:"2"})," has the wrong type for the injected identifier."]}),"\n",(0,t.jsx)(n.h2,{id:"benefits",children:"Benefits"}),"\n",(0,t.jsx)(n.h3,{id:"earlier-error-detection",children:"Earlier error detection"}),"\n",(0,t.jsx)(n.p,{children:"Catch type mismatches during development, not in production. The TypeScript compiler becomes your first line of defense against injection mistakes."}),"\n",(0,t.jsx)(n.h3,{id:"better-ide-support",children:"Better IDE support"}),"\n",(0,t.jsx)(n.p,{children:"Get autocomplete for service identifiers and automatic type inference. Your editor knows exactly what types are available and what each service returns."}),"\n",(0,t.jsx)(n.h3,{id:"self-documenting",children:"Self-documenting"}),"\n",(0,t.jsx)(n.p,{children:"The binding map serves as documentation of available services. New team members can look at the type definition to understand what services the container provides."}),"\n",(0,t.jsx)(n.h3,{id:"refactoring-safety",children:"Refactoring safety"}),"\n",(0,t.jsx)(n.p,{children:"The type system catches broken references when refactoring. Rename a service identifier and the compiler will show you everywhere that needs updating."}),"\n",(0,t.jsx)(n.h3,{id:"zero-runtime-cost",children:"Zero runtime cost"}),"\n",(0,t.jsx)(n.p,{children:"All benefits come from compile-time type checking. There's no additional JavaScript generated and no performance overhead at runtime."}),"\n",(0,t.jsx)(n.h2,{id:"package-information",children:"Package information"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"npm"}),": ",(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/@inversifyjs/strongly-typed",children:(0,t.jsx)(n.code,{children:"@inversifyjs/strongly-typed"})})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"GitHub"}),": ",(0,t.jsx)(n.a,{href:"https://github.com/inversify/monorepo",children:"inversify/monorepo"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"License"}),": MIT"]}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},9979:function(e,n,r){r.d(n,{A:()=>a});var i=r(6820);r(5080);var t=r(929);function a({children:e,hidden:n,className:r}){return(0,i.jsx)("div",{role:"tabpanel",className:(0,t.A)("tabItem_T5qr",r),hidden:n,children:e})}},9274:function(e,n,r){r.d(n,{A:()=>j});var i=r(6820),t=r(5080),a=r(929),o=r(3890),s=r(6033),l=r(3357),c=r(8680),d=r(5738),p=r(1411),u=r(3210);function h(e){return t.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,t.isValidElement)(e)&&function(e){let{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function y({value:e,tabValues:n}){return n.some(n=>n.value===e)}var m=r(9332);function f({className:e,block:n,selectedValue:r,selectValue:t,tabValues:o}){let l=[],{blockElementScrollPositionUntilNextRender:c}=(0,s.a_)(),d=e=>{let n=e.currentTarget,i=o[l.indexOf(n)].value;i!==r&&(c(n),t(i))},p=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{let r=l.indexOf(e.currentTarget)+1;n=l[r]??l[0];break}case"ArrowLeft":{let r=l.indexOf(e.currentTarget)-1;n=l[r]??l[l.length-1]}}n?.focus()};return(0,i.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":n},e),children:o.map(({value:e,label:n,attributes:t})=>(0,i.jsx)("li",{role:"tab",tabIndex:r===e?0:-1,"aria-selected":r===e,ref:e=>{l.push(e)},onKeyDown:p,onClick:d,...t,className:(0,a.A)("tabs__item","tabItem_i_kE",t?.className,{"tabs__item--active":r===e}),children:n??e},e))})}function g({lazy:e,children:n,selectedValue:r}){let o=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){let e=o.find(e=>e.props.value===r);return e?(0,t.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,i.jsx)("div",{className:"margin-top--md",children:o.map((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==r}))})}function v(e){let n=function(e){let n,{defaultValue:r,queryString:i=!1,groupId:a}=e,o=function(e){let{values:n,children:r}=e;return(0,t.useMemo)(()=>{let e=n??h(r).map(({props:{value:e,label:n,attributes:r,default:i}})=>({value:e,label:n,attributes:r,default:i})),i=(0,p.XI)(e,(e,n)=>e.value===n.value);if(i.length>0)throw Error(`Docusaurus error: Duplicate values "${i.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`);return e},[n,r])}(e),[s,m]=(0,t.useState)(()=>(function({defaultValue:e,tabValues:n}){if(0===n.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!y({value:e,tabValues:n}))throw Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}let r=n.find(e=>e.default)??n[0];if(!r)throw Error("Unexpected error: 0 tabValues");return r.value})({defaultValue:r,tabValues:o})),[f,g]=function({queryString:e=!1,groupId:n}){let r=(0,l.W6)(),i=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,d.aZ)(i),(0,t.useCallback)(e=>{if(!i)return;let n=new URLSearchParams(r.location.search);n.set(i,e),r.replace({...r.location,search:n.toString()})},[i,r])]}({queryString:i,groupId:a}),[v,j]=function({groupId:e}){let n=e?`docusaurus.tab.${e}`:null,[r,i]=(0,u.Dv)(n);return[r,(0,t.useCallback)(e=>{n&&i.set(e)},[n,i])]}({groupId:a}),x=y({value:n=f??v,tabValues:o})?n:null;return(0,c.A)(()=>{x&&m(x)},[x]),{selectedValue:s,selectValue:(0,t.useCallback)(e=>{if(!y({value:e,tabValues:o}))throw Error(`Can't select invalid tab value=${e}`);m(e),g(e),j(e)},[g,j,o]),tabValues:o}}(e);return(0,i.jsxs)("div",{className:(0,a.A)(o.G.tabs.container,"tabs-container","tabList_GEBg"),children:[(0,i.jsx)(f,{...n,...e}),(0,i.jsx)(g,{...n,...e})]})}function j(e){let n=(0,m.A)();return(0,i.jsx)(v,{...e,children:h(e.children)},String(n))}}}]);