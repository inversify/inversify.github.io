"use strict";(self.webpackChunk_inversifyjs_inversify_docs_site=self.webpackChunk_inversifyjs_inversify_docs_site||[]).push([["2978"],{4171:function(n,e,i){i.r(e),i.d(e,{frontMatter:()=>h,toc:()=>f,default:()=>m,metadata:()=>a,assets:()=>u,contentTitle:()=>p});var a=JSON.parse('{"id":"fundamentals/di-hierarchy","title":"DI Hierarchy","description":"InversifyJS is a popular library for implementing inversion of control (IoC) and dependency injection (DI) in TypeScript applications. It supports hierarchical dependency injection, which can be a powerful tool in complex applications.","source":"@site/versioned_docs/version-7.x/fundamentals/di-hierarchy.mdx","sourceDirName":"fundamentals","slug":"/fundamentals/di-hierarchy","permalink":"/docs/fundamentals/di-hierarchy","draft":false,"unlisted":false,"tags":[],"version":"7.x","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"DI Hierarchy"},"sidebar":"tutorialSidebar","previous":{"title":"Binding","permalink":"/docs/fundamentals/binding"},"next":{"title":"Activation","permalink":"/docs/fundamentals/lifecycle/activation"}}'),r=i(9970),t=i(7245),o=i(7066),s=i(7699),c=i(1654),d=i(7049),l=i(126);let h={sidebar_position:2,title:"DI Hierarchy"},p="DI Hierarchy",u={},f=[{value:"Chained Resolution Mode",id:"chained-resolution-mode",level:2},{value:"Standard Resolution Mode",id:"standard-resolution-mode",level:3},{value:"Chained Resolution Mode",id:"chained-resolution-mode-1",level:3}];function g(n){let e={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",...(0,t.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"di-hierarchy",children:"DI Hierarchy"})}),"\n",(0,r.jsx)(e.p,{children:"InversifyJS is a popular library for implementing inversion of control (IoC) and dependency injection (DI) in TypeScript applications. It supports hierarchical dependency injection, which can be a powerful tool in complex applications."}),"\n",(0,r.jsx)(e.p,{children:"With InversifyJS's hierarchical injection system, you can create a hierarchy of containers where each container can have a parent container. This allows for better organization and separation of concerns in your application."}),"\n",(0,r.jsx)(e.p,{children:"When a dependency needs to be injected, InversifyJS starts by looking in the current container for a binding. If the binding is not found, it moves up the hierarchy to the parent container and continues the search. This process continues until a binding is found or the top-level parent container is reached."}),"\n",(0,r.jsx)(e.admonition,{title:"Binding overrides",type:"warning",children:(0,r.jsx)(e.p,{children:"Found bindings might override ancestor bindings even if their constraints are not met. For example, if a named binding is found in the child container for the requested service, that binding overrides parent bindings even if this binding is later discarded in a non-named resolution request."})}),"\n",(0,r.jsxs)(e.admonition,{title:"DI hierarchies and cached bindings",type:"warning",children:[(0,r.jsx)(e.p,{children:"When using hierarchical injection, be aware that cached bindings from the first resolution will be used for subsequent resolution, even if the call comes from another child container."}),(0,r.jsx)(l.A,{language:"ts",children:d}),(0,r.jsxs)(e.p,{children:["If this behaviour is unwanted, consider using ",(0,r.jsx)(e.code,{children:"ContainerModule"})," instead. This way, you can load it in both containers. Different containers will have different binding and therefore different cached values."]})]}),"\n",(0,r.jsx)(e.p,{children:"By using InversifyJS's hierarchical injection system, you can easily manage complex dependencies and keep your code clean and modular. It provides a flexible and scalable solution for handling dependencies in your TypeScript applications."}),"\n",(0,r.jsx)(l.A,{language:"ts",children:c}),"\n",(0,r.jsx)(e.h2,{id:"chained-resolution-mode",children:"Chained Resolution Mode"}),"\n",(0,r.jsxs)(e.p,{children:["InversifyJS supports two different resolution modes when working with container hierarchies: ",(0,r.jsx)(e.strong,{children:"standard resolution"})," and ",(0,r.jsx)(e.strong,{children:"chained resolution"}),"."]}),"\n",(0,r.jsx)(e.h3,{id:"standard-resolution-mode",children:"Standard Resolution Mode"}),"\n",(0,r.jsxs)(e.p,{children:["In standard resolution mode (the default behavior), InversifyJS follows a ",(0,r.jsx)(e.strong,{children:"first-found"})," approach:"]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"First, it searches for bindings in the current container"}),"\n",(0,r.jsx)(e.li,{children:"If bindings are found in the current container, those bindings are used exclusively"}),"\n",(0,r.jsx)(e.li,{children:"If no bindings are found in the current container, it moves up to the parent container"}),"\n",(0,r.jsx)(e.li,{children:"This process continues until bindings are found or the top-level container is reached"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"This means that if a child container has any bindings for a service, the parent container's bindings for that same service will be ignored entirely:"}),"\n",(0,r.jsx)(l.A,{language:"ts",children:s}),"\n",(0,r.jsx)(e.h3,{id:"chained-resolution-mode-1",children:"Chained Resolution Mode"}),"\n",(0,r.jsxs)(e.p,{children:["Chained resolution mode allows you to collect bindings from ",(0,r.jsx)(e.strong,{children:"all levels"})," of the container hierarchy. When using ",(0,r.jsx)(e.code,{children:"getAll()"})," or ",(0,r.jsx)(e.code,{children:"getAllAsync()"})," with the ",(0,r.jsx)(e.code,{children:"chained: true"})," option:"]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Bindings are collected from the current container"}),"\n",(0,r.jsx)(e.li,{children:"Then bindings are collected from the parent container"}),"\n",(0,r.jsx)(e.li,{children:"This continues recursively up the entire hierarchy"}),"\n",(0,r.jsx)(e.li,{children:"All collected bindings are combined and returned"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"This is particularly useful when you want to aggregate services from different layers of your application (e.g., core services from a parent container and feature-specific services from child containers)."}),"\n",(0,r.jsx)(l.A,{language:"ts",children:o})]})}function m(n={}){let{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(g,{...n})}):g(n)}},7066:function(n){n.exports="const parentContainer: Container = new Container();\n\nconst container: Container = new Container({\n  parent: parentContainer,\n});\n\nparentContainer.bind<Weapon>('Weapon').to(Katana);\ncontainer.bind<Weapon>('Weapon').to(Shuriken);\n\n// returns Weapon[] with both Katana and Shuriken instances\nconst weapons: Weapon[] = container.getAll<Weapon>('Weapon', { chained: true });"},7699:function(n){n.exports="const parentContainer: Container = new Container();\n\nconst container: Container = new Container({\n  parent: parentContainer,\n});\n\nparentContainer.bind<Weapon>('Weapon').to(Katana);\ncontainer.bind<Weapon>('Weapon').to(Shuriken);\n\n// returns Weapon[] with only a Shuriken instance\nconst weapons: Weapon[] = container.getAll<Weapon>('Weapon', {\n  chained: false,\n});"},1654:function(n){n.exports="class Katana {}\n\nconst parentContainer: Container = new Container();\nparentContainer.bind(weaponIdentifier).to(Katana);\n\nconst childContainer: Container = new Container({ parent: parentContainer });\n\nconst katana: Katana = childContainer.get(weaponIdentifier);"},7049:function(n){n.exports="@injectable()\nclass Samurai {\n  constructor(\n    @inject(Katana)\n    public katana: Katana,\n  ) {}\n}\n\nconst parentContainer: Container = new Container();\nparentContainer.bind(Samurai).toSelf().inSingletonScope();\nparentContainer.bind(Katana).toSelf();\n\nconst childContainer: Container = new Container({ parent: parentContainer });\nchildContainer.bind(Katana).to(LegendaryKatana);\n\n// The result of this resolution will be cached in the samurai binding\nchildContainer.get(Samurai);\n\n// This samurai will have a LegendaryKatana injected\nconst samurai: Samurai = parentContainer.get(Samurai);"}}]);