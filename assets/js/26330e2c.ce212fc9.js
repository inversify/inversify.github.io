"use strict";(self.webpackChunk_inversifyjs_inversify_docs_site=self.webpackChunk_inversifyjs_inversify_docs_site||[]).push([["2823"],{8716:function(n,e,i){i.r(e),i.d(e,{frontMatter:()=>l,default:()=>m,toc:()=>g,metadata:()=>a,assets:()=>h,contentTitle:()=>c});var a=JSON.parse('{"id":"api/container","title":"Container","description":"The InversifyJS container is where dependencies are first configured through binding and, possibly later, reconfigured and removed. The container can be worked on directly in this regard or container modules can be utilized.","source":"@site/versioned_docs/version-6.x/api/container.mdx","sourceDirName":"api","slug":"/api/container","permalink":"/docs/6.x/api/container","draft":false,"unlisted":false,"tags":[],"version":"6.x","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Container"},"sidebar":"tutorialSidebar","previous":{"title":"Binding Syntax","permalink":"/docs/6.x/api/binding-syntax"},"next":{"title":"Container Module","permalink":"/docs/6.x/api/container-module"}}'),t=i(3112),r=i(1131),s=i(1449),o=i(1294),d=i(9778);let l={sidebar_position:2,title:"Container"},c="Container",h={},g=[{value:"Container Options",id:"container-options",level:2},{value:"defaultScope",id:"defaultscope",level:3},{value:"autoBindInjectable",id:"autobindinjectable",level:3},{value:"skipBaseClassChecks",id:"skipbaseclasschecks",level:3},{value:"Container.merge",id:"containermerge",level:2},{value:"applyCustomMetadataReader",id:"applycustommetadatareader",level:2},{value:"applyMiddleware",id:"applymiddleware",level:2},{value:"bind",id:"bind",level:2},{value:"createChild",id:"createchild",level:2},{value:"get",id:"get",level:2},{value:"getAsync",id:"getasync",level:2},{value:"getNamed",id:"getnamed",level:2},{value:"getNamedAsync",id:"getnamedasync",level:2},{value:"getTagged",id:"gettagged",level:2},{value:"getTaggedAsync",id:"gettaggedasync",level:2},{value:"getAll",id:"getall",level:2},{value:"getAllAsync",id:"getallasync",level:2},{value:"getAllNamed",id:"getallnamed",level:2},{value:"getAllNamedAsync",id:"getallnamedasync",level:2},{value:"getAllTagged",id:"getalltagged",level:2},{value:"getAllTaggedAsync",id:"getalltaggedasync",level:2},{value:"isBound",id:"isbound",level:2},{value:"isCurrentBound",id:"iscurrentbound",level:2},{value:"isBoundNamed",id:"isboundnamed",level:2},{value:"isBoundTagged",id:"isboundtagged",level:2},{value:"load",id:"load",level:2},{value:"loadAsync",id:"loadasync",level:2},{value:"rebind",id:"rebind",level:2},{value:"rebindAsync",id:"rebindasync",level:2},{value:"resolve",id:"resolve",level:2},{value:"onActivation",id:"onactivation",level:2},{value:"onDeactivation",id:"ondeactivation",level:2},{value:"restore",id:"restore",level:2},{value:"snapshot",id:"snapshot",level:2},{value:"tryGet",id:"tryget",level:2},{value:"tryGetAsync",id:"trygetasync",level:2},{value:"tryGetNamed",id:"trygetnamed",level:2},{value:"tryGetNamedAsync",id:"trygetnamedasync",level:2},{value:"tryGetTagged",id:"trygettagged",level:2},{value:"tryGetTaggedAsync",id:"trygettaggedasync",level:2},{value:"tryGetAll",id:"trygetall",level:2},{value:"tryGetAllAsync",id:"trygetallasync",level:2},{value:"tryGetAllNamed",id:"trygetallnamed",level:2},{value:"tryGetAllNamedAsync",id:"trygetallnamedasync",level:2},{value:"tryGetAllTagged",id:"trygetalltagged",level:2},{value:"tryGetAllTaggedAsync",id:"trygetalltaggedasync",level:2},{value:"unbind",id:"unbind",level:2},{value:"unbindAsync",id:"unbindasync",level:2},{value:"unbindAll",id:"unbindall",level:2},{value:"unbindAllAsync",id:"unbindallasync",level:2},{value:"unload",id:"unload",level:2},{value:"unloadAsync",id:"unloadasync",level:2},{value:"parent",id:"parent",level:2},{value:"id",id:"id",level:2}];function u(n){let e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,r.a)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"container",children:"Container"})}),"\n",(0,t.jsxs)(e.p,{children:["The InversifyJS container is where dependencies are first configured through binding and, possibly later, reconfigured and removed. The container can be worked on directly in this regard or container modules can be utilized.\nYou can query the configuration and resolve configured dependencies with the ",(0,t.jsx)(e.code,{children:"get"})," methods.\nYou can react to resolutions with container activation handlers and unbinding with container deactivation handlers.\nYou can create container hierarchies where container ascendants can supply the dependencies for descendants.\nFor testing, state can be saved as a snapshot on a stack and later restored.\nFor advanced control, you can apply middleware to intercept the resolution request and the resolved dependency.\nYou can even provide your own annotation solution."]}),"\n",(0,t.jsx)(e.h2,{id:"container-options",children:"Container Options"}),"\n",(0,t.jsx)(e.p,{children:"Container options can be passed to the Container constructor, and defaults will be provided if you do not or if you do but omit an option.\nOptions can be changed after construction and will be shared by child containers created from the Container if you do not provide options for them."}),"\n",(0,t.jsx)(e.h3,{id:"defaultscope",children:"defaultScope"}),"\n",(0,t.jsxs)(e.p,{children:["The default scope is ",(0,t.jsx)(e.code,{children:"transient"})," when binding to/toSelf/toDynamicValue/toService.\nOther bindings can only be bound in ",(0,t.jsx)(e.code,{children:"singleton"})," scope."]}),"\n",(0,t.jsxs)(e.p,{children:["You can use container options to change the default scope for the bindings that default to ",(0,t.jsx)(e.code,{children:"transient"})," at the application level:"]}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"const container: Container = new Container({ defaultScope: 'Singleton' });\n\n// You can configure the scope when declaring bindings:\ncontainer.bind<Warrior>(warriorServiceId).to(Ninja).inTransientScope();"}),"\n",(0,t.jsx)(e.h3,{id:"autobindinjectable",children:"autoBindInjectable"}),"\n",(0,t.jsxs)(e.p,{children:["You can use this to activate automatic binding for ",(0,t.jsx)(e.code,{children:"@injectable()"})," decorated classes.\nWhenever an instance is requested via ",(0,t.jsx)(e.code,{children:"get"}),", the container attempts to add a binding if no binding is found for the requested service."]}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"const container: Container = new Container({ autoBindInjectable: true });\n\n// returns false\ncontainer.isBound(Ninja);\n// returns a Ninja\ncontainer.get(Ninja);\n// returns true\ncontainer.isBound(Ninja);"}),"\n",(0,t.jsx)(e.p,{children:"Manually defined bindings will take precedence:"}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"const container: Container = new Container({ autoBindInjectable: true });\n\n// returns a Ninja\ncontainer.bind(Ninja).to(NinjaMaster);\n// returns NinjaMaster\ncontainer.get(Ninja);"}),"\n",(0,t.jsx)(e.h3,{id:"skipbaseclasschecks",children:"skipBaseClassChecks"}),"\n",(0,t.jsxs)(e.p,{children:["You can use this to skip checking base classes for the ",(0,t.jsx)(e.code,{children:"@injectable"})," property, which is especially useful if any of your ",(0,t.jsx)(e.code,{children:"@injectable"})," classes extend classes that you don't control (third-party classes). By default, this value is ",(0,t.jsx)(e.code,{children:"false"}),"."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"const container = new Container({ skipBaseClassChecks: true });\n"})}),"\n",(0,t.jsx)(e.h2,{id:"containermerge",children:"Container.merge"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"Container.merge(a: interfaces.Container, b: interfaces.Container, ...containers: interfaces.Container[]): interfaces.Container;\n"})}),"\n",(0,t.jsx)(e.p,{children:"Creates a new Container containing the bindings ( cloned bindings ) of two or more containers:"}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"@injectable()\nclass Ninja {\n  public readonly name: string = 'Ninja';\n}\n\n@injectable()\nclass Shuriken {\n  public readonly name: string = 'Shuriken';\n}\n\nconst NINJA_EXPANSION_TYPES = {\n  Ninja: 'Ninja',\n  Shuriken: 'Shuriken',\n} satisfies Record<string, string>;\n\nconst ninjaExpansionContainer: Container = new Container();\n\nninjaExpansionContainer.bind<Ninja>(NINJA_EXPANSION_TYPES.Ninja).to(Ninja);\nninjaExpansionContainer\n  .bind<Shuriken>(NINJA_EXPANSION_TYPES.Shuriken)\n  .to(Shuriken);\n\n@injectable()\nclass Samurai {\n  public readonly name: string = 'Samurai';\n}\n\n@injectable()\nclass Katana {\n  public name = 'Katana';\n}\n\nconst SAMURAI_EXPANSION_TYPES = {\n  Katana: 'Katana',\n  Samurai: 'Samurai',\n} satisfies Record<string, string>;\n\nconst samuraiExpansionContainer: Container = new Container();\nsamuraiExpansionContainer\n  .bind<Samurai>(SAMURAI_EXPANSION_TYPES.Samurai)\n  .to(Samurai);\nsamuraiExpansionContainer\n  .bind<Katana>(SAMURAI_EXPANSION_TYPES.Katana)\n  .to(Katana);\n\nconst gameContainer: interfaces.Container = Container.merge(\n  ninjaExpansionContainer,\n  samuraiExpansionContainer,\n);"}),"\n",(0,t.jsx)(e.h2,{id:"applycustommetadatareader",children:"applyCustomMetadataReader"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"applyCustomMetadataReader(metadataReader: interfaces.MetadataReader): void;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Sets a custom metadata reader. See ",(0,t.jsx)(e.a,{href:"/docs/6.x/fundamentals/lifecycle/middleware",children:"middleware"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"applymiddleware",children:"applyMiddleware"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"applyMiddleware(...middleware: interfaces.Middleware[]): void;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["An advanced feature that can be used for cross cutting concerns. See ",(0,t.jsx)(e.a,{href:"/docs/6.x/fundamentals/lifecycle/middleware",children:"middleware"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"bind",children:"bind"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"bind<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): interfaces.BindingToSyntax<T>\n"})}),"\n",(0,t.jsx)(e.p,{children:"Sets a new binding."}),"\n",(0,t.jsx)(e.h2,{id:"createchild",children:"createChild"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"createChild(containerOptions?: interfaces.ContainerOptions): Container;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Create a ",(0,t.jsx)(e.a,{href:"/docs/6.x/fundamentals/di-hierarchy",children:"container hierarchy"}),". Parent ",(0,t.jsx)(e.code,{children:"ContainerOptions"})," are provided by default."]}),"\n",(0,t.jsx)(e.h2,{id:"get",children:"get"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"get<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): T;\n"})}),"\n",(0,t.jsx)(e.p,{children:"Resolves a dependency by its runtime identifier. The runtime identifier must be associated with only one binding and the binding must be synchronously resolved, otherwise an error is thrown."}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"const container: Container = new Container();\ncontainer.bind<Weapon>('Weapon').to(Katana);\n\nconst katana: Weapon = container.get<Weapon>('Weapon');"}),"\n",(0,t.jsx)(e.h2,{id:"getasync",children:"getAsync"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"getAsync<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): Promise<T>;\n"})}),"\n",(0,t.jsx)(e.p,{children:"Resolves a dependency by its runtime identifier. The runtime identifier must be associated with only one binding, otherwise an error is thrown."}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"async function buildLevel1(): Promise<Level1> {\n  return new Level1();\n}\n\nconst container: Container = new Container();\ncontainer\n  .bind('Level1')\n  .toDynamicValue(async (): Promise<Level1> => buildLevel1());\n\nconst level1: Promise<Level1> = container.getAsync<Level1>('Level1');"}),"\n",(0,t.jsx)(e.h2,{id:"getnamed",children:"getNamed"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"getNamed<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, named: string | number | symbol): T;\n"})}),"\n",(0,t.jsx)(e.p,{children:"Resolves a dependency by its runtime identifier that matches the given named constraint. The runtime identifier must be associated with only one binding and the binding must be synchronously resolved, otherwise an error is thrown:"}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"const container: Container = new Container();\ncontainer.bind<Weapon>('Weapon').to(Katana).whenTargetNamed('melee');\ncontainer.bind<Weapon>('Weapon').to(Shuriken).whenTargetNamed('ranged');\n\nconst katana: Weapon = container.getNamed<Weapon>('Weapon', 'melee');\nconst shuriken: Weapon = container.getNamed<Weapon>('Weapon', 'ranged');"}),"\n",(0,t.jsx)(e.h2,{id:"getnamedasync",children:"getNamedAsync"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"getNamedAsync<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, named: string | number | symbol): Promise<T>;\n"})}),"\n",(0,t.jsx)(e.p,{children:"Resolves a dependency by its runtime identifier that matches the given named constraint. The runtime identifier must be associated with only one binding, otherwise an error is thrown:"}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"const container: Container = new Container();\ncontainer\n  .bind<Weapon>('Weapon')\n  .toDynamicValue(async () => new Katana())\n  .whenTargetNamed('melee');\ncontainer\n  .bind<Weapon>('Weapon')\n  .toDynamicValue(async () => new Shuriken())\n  .whenTargetNamed('ranged');\n\nconst katana: Promise<Weapon> = container.getNamedAsync<Weapon>(\n  'Weapon',\n  'melee',\n);\nconst shuriken: Promise<Weapon> = container.getNamedAsync<Weapon>(\n  'Weapon',\n  'ranged',\n);"}),"\n",(0,t.jsx)(e.h2,{id:"gettagged",children:"getTagged"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"getTagged<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, key: string | number | symbol, value: unknown): T;\n"})}),"\n",(0,t.jsx)(e.p,{children:"Resolves a dependency by its runtime identifier that matches the given tagged constraint. The runtime identifier must be associated with only one binding and the binding must be synchronously resolved, otherwise an error is thrown:"}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"const container: Container = new Container();\ncontainer\n  .bind<Weapon>('Weapon')\n  .to(Katana)\n  .whenTargetTagged('faction', 'samurai');\ncontainer\n  .bind<Weapon>('Weapon')\n  .to(Shuriken)\n  .whenTargetTagged('faction', 'ninja');\n\nconst katana: Weapon = container.getTagged<Weapon>(\n  'Weapon',\n  'faction',\n  'samurai',\n);\nconst shuriken: Weapon = container.getTagged<Weapon>(\n  'Weapon',\n  'faction',\n  'ninja',\n);"}),"\n",(0,t.jsx)(e.h2,{id:"gettaggedasync",children:"getTaggedAsync"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"getTaggedAsync<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, key: string | number | symbol, value: unknown): Promise<T>;\n"})}),"\n",(0,t.jsx)(e.p,{children:"Resolves a dependency by its runtime identifier that matches the given tagged constraint. The runtime identifier must be associated with only one binding, otherwise an error is thrown:"}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"const container: Container = new Container();\ncontainer\n  .bind<Weapon>('Weapon')\n  .toDynamicValue(async () => new Katana())\n  .whenTargetTagged('faction', 'samurai');\ncontainer\n  .bind<Weapon>('Weapon')\n  .toDynamicValue(async () => new Shuriken())\n  .whenTargetTagged('faction', 'ninja');\n\nconst katana: Promise<Weapon> = container.getTaggedAsync<Weapon>(\n  'Weapon',\n  'faction',\n  'samurai',\n);\nconst shuriken: Promise<Weapon> = container.getTaggedAsync<Weapon>(\n  'Weapon',\n  'faction',\n  'ninja',\n);"}),"\n",(0,t.jsx)(e.h2,{id:"getall",children:"getAll"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"getAll(serviceIdentifier: interfaces.ServiceIdentifier<T>, options?: interfaces.GetAllOptions): T[];\n"})}),"\n",(0,t.jsx)(e.p,{children:"Get all available bindings for a given identifier. All the bindings must be synchronously resolved, otherwise an error is thrown:"}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"const container: Container = new Container();\ncontainer.bind<Weapon>('Weapon').to(Katana);\ncontainer.bind<Weapon>('Weapon').to(Shuriken);\n\nconst weapons: Weapon[] = container.getAll<Weapon>('Weapon');"}),"\n",(0,t.jsxs)(e.p,{children:["Keep in mind ",(0,t.jsx)(e.code,{children:"container.getAll"})," doesn't enforce binding contraints by default in the root level, enable the ",(0,t.jsx)(e.code,{children:"enforceBindingConstraints"})," flag to force this binding constraint check:"]}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"const container: Container = new Container();\ncontainer\n  .bind<Weapon>('Weapon')\n  .to(Katana)\n  .when(() => true);\ncontainer\n  .bind<Weapon>('Weapon')\n  .to(Shuriken)\n  .when(() => false);\n\n// returns [new Katana(), new Shuriken()]\nconst allWeapons: Weapon[] = container.getAll<Weapon>('Weapon');\n\n// returns [new Katana()]\nconst notAllWeapons: Weapon[] = container.getAll<Weapon>('Weapon', {\n  enforceBindingConstraints: true,\n});"}),"\n",(0,t.jsx)(e.h2,{id:"getallasync",children:"getAllAsync"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"getAllAsync<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, options?: interfaces.GetAllOptions): Promise<T[]>\n"})}),"\n",(0,t.jsx)(e.p,{children:"Get all available bindings for a given identifier:"}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"const container: Container = new Container();\ncontainer.bind<Weapon>('Weapon').toDynamicValue(async () => new Katana());\ncontainer.bind<Weapon>('Weapon').to(Shuriken);\n\nconst weapons: Promise<Weapon[]> = container.getAllAsync<Weapon>('Weapon');"}),"\n",(0,t.jsxs)(e.p,{children:["Keep in mind ",(0,t.jsx)(e.code,{children:"container.getAll"})," doesn't enforce binding contraints by default in the root level, enable the ",(0,t.jsx)(e.code,{children:"enforceBindingConstraints"})," flag to force this binding constraint check:"]}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"const container: Container = new Container();\ncontainer\n  .bind<Weapon>('Weapon')\n  .toDynamicValue(async () => new Katana())\n  .when(() => true);\ncontainer\n  .bind<Weapon>('Weapon')\n  .to(Shuriken)\n  .when(() => false);\n\n// returns [new Katana(), new Shuriken()]\nconst allWeapons: Promise<Weapon[]> = container.getAllAsync<Weapon>('Weapon');\n\n// returns [new Katana()]\nconst notAllWeapons: Promise<Weapon[]> = container.getAllAsync<Weapon>(\n  'Weapon',\n  {\n    enforceBindingConstraints: true,\n  },\n);"}),"\n",(0,t.jsx)(e.h2,{id:"getallnamed",children:"getAllNamed"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"getAllNamed<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, named: string | number | symbol): T[];\n"})}),"\n",(0,t.jsx)(e.p,{children:"Resolves all the dependencies by its runtime identifier that matches the given named constraint. All the binding must be synchronously resolved, otherwise an error is thrown:"}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"const container: Container = new Container();\n\ninterface Intl {\n  hello?: string;\n  goodbye?: string;\n}\n\ncontainer\n  .bind<Intl>('Intl')\n  .toConstantValue({ hello: 'bonjour' })\n  .whenTargetNamed('fr');\ncontainer\n  .bind<Intl>('Intl')\n  .toConstantValue({ goodbye: 'au revoir' })\n  .whenTargetNamed('fr');\n\ncontainer\n  .bind<Intl>('Intl')\n  .toConstantValue({ hello: 'hola' })\n  .whenTargetNamed('es');\ncontainer\n  .bind<Intl>('Intl')\n  .toConstantValue({ goodbye: 'adios' })\n  .whenTargetNamed('es');\n\nconst fr: Intl[] = container.getAllNamed<Intl>('Intl', 'fr');\n\nconst es: Intl[] = container.getAllNamed<Intl>('Intl', 'es');"}),"\n",(0,t.jsx)(e.h2,{id:"getallnamedasync",children:"getAllNamedAsync"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"getAllNamedAsync<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, named: string | number | symbol): Promise<T[]>;\n"})}),"\n",(0,t.jsx)(e.p,{children:"Resolves all the dependencies by its runtime identifier that matches the given named constraint:"}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"const container: Container = new Container();\n\ninterface Intl {\n  hello?: string;\n  goodbye?: string;\n}\n\ncontainer\n  .bind<Intl>('Intl')\n  .toDynamicValue(async () => ({ hello: 'bonjour' }))\n  .whenTargetNamed('fr');\ncontainer\n  .bind<Intl>('Intl')\n  .toDynamicValue(async () => ({ goodbye: 'au revoir' }))\n  .whenTargetNamed('fr');\n\ncontainer\n  .bind<Intl>('Intl')\n  .toDynamicValue(async () => ({ hello: 'hola' }))\n  .whenTargetNamed('es');\ncontainer\n  .bind<Intl>('Intl')\n  .toDynamicValue(async () => ({ goodbye: 'adios' }))\n  .whenTargetNamed('es');\n\nconst fr: Promise<Intl[]> = container.getAllNamedAsync<Intl>('Intl', 'fr');\n\nconst es: Promise<Intl[]> = container.getAllNamedAsync<Intl>('Intl', 'es');"}),"\n",(0,t.jsx)(e.h2,{id:"getalltagged",children:"getAllTagged"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"getAllTagged<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, key: string | number | symbol, value: unknown): T[];\n"})}),"\n",(0,t.jsx)(e.p,{children:"Resolves all the dependencies by its runtime identifier that matches the given tagged constraint. All the binding must be synchronously resolved, otherwise an error is thrown:"}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"const container: Container = new Container();\n\ninterface Intl {\n  hello?: string;\n  goodbye?: string;\n}\n\ncontainer\n  .bind<Intl>('Intl')\n  .toConstantValue({ hello: 'bonjour' })\n  .whenTargetTagged('lang', 'fr');\ncontainer\n  .bind<Intl>('Intl')\n  .toConstantValue({ goodbye: 'au revoir' })\n  .whenTargetTagged('lang', 'fr');\n\ncontainer\n  .bind<Intl>('Intl')\n  .toConstantValue({ hello: 'hola' })\n  .whenTargetTagged('lang', 'es');\ncontainer\n  .bind<Intl>('Intl')\n  .toConstantValue({ goodbye: 'adios' })\n  .whenTargetTagged('lang', 'es');\n\nconst fr: Intl[] = container.getAllTagged<Intl>('Intl', 'lang', 'fr');\n\nconst es: Intl[] = container.getAllTagged<Intl>('Intl', 'lang', 'es');"}),"\n",(0,t.jsx)(e.h2,{id:"getalltaggedasync",children:"getAllTaggedAsync"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"getAllTaggedAsync<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, key: string | number | symbol, value: unknown): Promise<T[]>;\n"})}),"\n",(0,t.jsx)(e.p,{children:"Resolves all the dependencies by its runtime identifier that matches the given tagged constraint:"}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"const container: Container = new Container();\n\ninterface Intl {\n  hello?: string;\n  goodbye?: string;\n}\n\ncontainer\n  .bind<Intl>('Intl')\n  .toDynamicValue(async () => ({ hello: 'bonjour' }))\n  .whenTargetTagged('lang', 'fr');\ncontainer\n  .bind<Intl>('Intl')\n  .toDynamicValue(async () => ({ goodbye: 'au revoir' }))\n  .whenTargetTagged('lang', 'fr');\n\ncontainer\n  .bind<Intl>('Intl')\n  .toDynamicValue(async () => ({ hello: 'hola' }))\n  .whenTargetTagged('lang', 'es');\ncontainer\n  .bind<Intl>('Intl')\n  .toDynamicValue(async () => ({ goodbye: 'adios' }))\n  .whenTargetTagged('lang', 'es');\n\nconst fr: Promise<Intl[]> = container.getAllTaggedAsync<Intl>(\n  'Intl',\n  'lang',\n  'fr',\n);\n\nconst es: Promise<Intl[]> = container.getAllTaggedAsync<Intl>(\n  'Intl',\n  'lang',\n  'es',\n);"}),"\n",(0,t.jsx)(e.h2,{id:"isbound",children:"isBound"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"isBound(serviceIdentifier: interfaces.ServiceIdentifier<unknown>): boolean;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["You can use the ",(0,t.jsx)(e.code,{children:"isBound"})," method to check if there are registered bindings for a given service identifier."]}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"interface Warrior {\n  kind: string;\n}\n\nconst katanaSymbol: symbol = Symbol.for('Katana');\nconst warriorSymbol: symbol = Symbol.for('Warrior');\n\n@injectable()\nclass Ninja implements Warrior {\n  public readonly kind: string = 'ninja';\n}\n\n@injectable()\nclass Katana {}\n\nconst container: Container = new Container();\ncontainer.bind<Warrior>(Ninja).to(Ninja);\ncontainer.bind<Warrior>(warriorSymbol).to(Ninja);\n\n// returns true\nconst isNinjaBound: boolean = container.isBound(Ninja);\n// returns true\nconst isWarriorSymbolBound: boolean = container.isBound(warriorSymbol);\n// returns false\nconst isKatanaBound: boolean = container.isBound(Katana);\n// returns false\nconst isKatanaSymbolBound: boolean = container.isBound(katanaSymbol);"}),"\n",(0,t.jsx)(e.h2,{id:"iscurrentbound",children:"isCurrentBound"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"isCurrentBound(serviceIdentifier: interfaces.ServiceIdentifier<unknown>): boolean;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["You can use the ",(0,t.jsx)(e.code,{children:"isCurrentBound"})," method to check if there are registered bindings for a given service identifier only in the current container."]}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"interface Warrior {\n  kind: string;\n}\n\nconst katanaSymbol: symbol = Symbol.for('Katana');\nconst warriorSymbol: symbol = Symbol.for('Warrior');\n\n@injectable()\nclass Ninja implements Warrior {\n  public readonly kind: string = 'ninja';\n}\n\n@injectable()\nclass Katana {}\n\nconst container: Container = new Container();\ncontainer.bind<Warrior>(Ninja).to(Ninja);\ncontainer.bind<Warrior>(warriorSymbol).to(Ninja);\n\nconst containerChild: Container = container.createChild();\n\ncontainerChild.bind<Katana>(Katana).to(Katana);\ncontainerChild.bind<Katana>(katanaSymbol).to(Katana);\n\n// returns false\nconst isNinjaBound: boolean = containerChild.isCurrentBound(Ninja);\n// returns false\nconst isWarriorSymbolBound: boolean =\n  containerChild.isCurrentBound(warriorSymbol);\n// returns true\nconst isKatanaBound: boolean = containerChild.isCurrentBound(Katana);\n// returns true\nconst isKatanaSymbolBound: boolean =\n  containerChild.isCurrentBound(katanaSymbol);"}),"\n",(0,t.jsx)(e.h2,{id:"isboundnamed",children:"isBoundNamed"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"isBoundNamed(serviceIdentifier: interfaces.ServiceIdentifier<unknown>, named: string): boolean;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["You can use the ",(0,t.jsx)(e.code,{children:"isBoundNamed"})," method to check if there are registered bindings for a given service identifier with a given named constraint."]}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"const divisor: string = 'divisor';\nconst invalidDivisor: string = 'InvalidDivisor';\nconst validDivisor: string = 'ValidDivisor';\nconst container: Container = new Container();\n\ncontainer\n  .bind<number>(divisor)\n  .toConstantValue(0)\n  .whenTargetNamed(invalidDivisor);\n\n// returns true\nconst isDivisorBoundInInvalidDivisorName: boolean = container.isBoundNamed(\n  divisor,\n  invalidDivisor,\n);\n\ncontainer\n  .bind<number>(divisor)\n  .toConstantValue(1)\n  .whenTargetNamed(validDivisor);\n\n// returns true\nconst isDivisorBoundInValidDivisorName: boolean = container.isBoundNamed(\n  divisor,\n  validDivisor,\n);"}),"\n",(0,t.jsx)(e.h2,{id:"isboundtagged",children:"isBoundTagged"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"isBoundTagged(serviceIdentifier: interfaces.ServiceIdentifier<unknown>, key: string, value: unknown): boolean;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["You can use the ",(0,t.jsx)(e.code,{children:"isBoundTagged"})," method to check if there are registered bindings for a given service identifier with a given tagged constraint."]}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"const divisor: string = 'divisor';\nconst container: Container = new Container();\n\ncontainer\n  .bind<number>(divisor)\n  .toConstantValue(0)\n  .whenTargetTagged('isValidDivisor', false);\n\n// returns true\nconst isDivisorBoundInIsValidDivisorFalseTag: boolean = container.isBoundTagged(\n  divisor,\n  'isValidDivisor',\n  false,\n);\n\ncontainer\n  .bind<number>(divisor)\n  .toConstantValue(1)\n  .whenTargetTagged('isValidDivisor', true);\n\n// returns true\nconst isDivisorBoundInIsValidDivisorTrueTag: boolean = container.isBoundTagged(\n  divisor,\n  'isValidDivisor',\n  true,\n);"}),"\n",(0,t.jsx)(e.h2,{id:"load",children:"load"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"load(...modules: interfaces.ContainerModule[]): void;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Calls the registration method of each module. See ",(0,t.jsx)(e.a,{href:"/docs/6.x/api/container-module",children:"ContainerModule API docs"})]}),"\n",(0,t.jsx)(e.h2,{id:"loadasync",children:"loadAsync"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"loadAsync(...modules: interfaces.AsyncContainerModule[]): Promise<void>;\n"})}),"\n",(0,t.jsx)(e.p,{children:"As per load but for asynchronous registration."}),"\n",(0,t.jsx)(e.h2,{id:"rebind",children:"rebind"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"rebind<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): interfaces.BindingToSyntax<T>;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Replaces all the existing bindings for a given ",(0,t.jsx)(e.code,{children:"serviceIdentifier"}),".\nThe function returns an instance of ",(0,t.jsx)(e.code,{children:"BindingToSyntax"})," which allows to create the replacement binding."]}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"const serviceId: string = 'serviceId';\n\nconst container: Container = new Container();\ncontainer.bind<number>(serviceId).toConstantValue(1);\ncontainer.bind<number>(serviceId).toConstantValue(2);\n\n// returns [1, 2]\nconst valuesBeforeRebind: number[] = container.getAll(serviceId);\n\ncontainer.rebind<number>(serviceId).toConstantValue(3);\n\n// returns [3]\nconst valuesAfterRebind: number[] = container.getAll(serviceId);"}),"\n",(0,t.jsx)(e.h2,{id:"rebindasync",children:"rebindAsync"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"rebindAsync<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): Promise<interfaces.BindingToSyntax<T>>;\n"})}),"\n",(0,t.jsx)(e.p,{children:"This is an asynchronous version of rebind. If you know deactivation is asynchronous then this should be used."}),"\n",(0,t.jsx)(e.h2,{id:"resolve",children:"resolve"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"resolve<T>(constructor: interfaces.Newable<T>): T;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Resolve works the same way ",(0,t.jsx)(e.code,{children:"container.get"}),", but an automatic binding will be added to the container if no bindings are found for the type provided."]}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:"import { Container, injectable } from 'inversify';\n\n@injectable()\nclass Katana {\n  public hit() {\n    return 'cut!';\n  }\n}\n\n@injectable()\nclass Ninja implements Ninja {\n  public katana: Katana;\n\n  constructor(katana: Katana) {\n    this.katana = katana;\n  }\n\n  public fight() {\n    return this.katana.hit();\n  }\n}\n\nconst container: Container = new Container();\ncontainer.bind(Katana).toSelf();\n\n// Ninja is provided and a Ninja bindong is added to the container\nconst ninja: Ninja = container.resolve(Ninja);"}),"\n",(0,t.jsxs)(e.p,{children:["Please note that it only allows to skip declaring a binding for the root element in the dependency graph (composition root). All the sub-dependencies (e.g. ",(0,t.jsx)(e.code,{children:"Katana"})," in the preceding example) will require a binding to be declared."]}),"\n",(0,t.jsx)(e.h2,{id:"onactivation",children:"onActivation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"onActivation<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, onActivation: interfaces.BindingActivation<T>): void;\n"})}),"\n",(0,t.jsx)(e.p,{children:"Adds an activation handler for all services associated to the service identifier."}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:s}),"\n",(0,t.jsx)(e.h2,{id:"ondeactivation",children:"onDeactivation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"onDeactivation<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, onDeactivation: interfaces.BindingDeactivation<T>): void;\n"})}),"\n",(0,t.jsx)(e.p,{children:"Adds a deactivation handler for a service identifier."}),"\n",(0,t.jsx)(d.Z,{language:"ts",children:o}),"\n",(0,t.jsx)(e.h2,{id:"restore",children:"restore"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"restore(): void;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Restore container state to last snapshot. Refer to the ",(0,t.jsx)(e.a,{href:"/docs/6.x/fundamentals/snapshot",children:"docs"})," for more information."]}),"\n",(0,t.jsx)(e.h2,{id:"snapshot",children:"snapshot"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"snapshot(): void;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Save the state of the container to be later restored with the restore method. Refer to the ",(0,t.jsx)(e.a,{href:"/docs/6.x/fundamentals/snapshot",children:"docs"})," for more information."]}),"\n",(0,t.jsx)(e.h2,{id:"tryget",children:"tryGet"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"tryGet<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): T | undefined;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Same as ",(0,t.jsx)(e.code,{children:"container.get"}),", but returns ",(0,t.jsx)(e.code,{children:"undefined"})," in the event no bindings are bound to ",(0,t.jsx)(e.code,{children:"serviceIdentifier"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"trygetasync",children:"tryGetAsync"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"tryGetAsync<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): Promise<T | undefined>;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Same as ",(0,t.jsx)(e.code,{children:"container.getAsync"}),", but returns ",(0,t.jsx)(e.code,{children:"Promise<undefined>"})," in the event no bindings are bound to ",(0,t.jsx)(e.code,{children:"serviceIdentifier"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"trygetnamed",children:"tryGetNamed"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"tryGetNamed<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, named: string | number | symbol): T | undefined;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Same as ",(0,t.jsx)(e.code,{children:"container.getNamed"}),", but returns ",(0,t.jsx)(e.code,{children:"undefined"})," in the event no bindings are bound to ",(0,t.jsx)(e.code,{children:"serviceIdentifier"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"trygetnamedasync",children:"tryGetNamedAsync"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"tryGetNamedAsync<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, named: string | number | symbol): Promise<T | undefined>;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Same as ",(0,t.jsx)(e.code,{children:"container.getNamedAsync"}),", but returns ",(0,t.jsx)(e.code,{children:"Promise<undefined>"})," in the event no bindings are bound to ",(0,t.jsx)(e.code,{children:"serviceIdentifier"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"trygettagged",children:"tryGetTagged"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"tryGetTagged<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, key: string | number | symbol, value: unknown): T | undefined;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Same as ",(0,t.jsx)(e.code,{children:"container.getTagged"}),", but returns ",(0,t.jsx)(e.code,{children:"undefined"})," in the event no bindings are bound to ",(0,t.jsx)(e.code,{children:"serviceIdentifier"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"trygettaggedasync",children:"tryGetTaggedAsync"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"tryGetTaggedAsync<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, key: string | number | symbol, value: unknown): Promise<T | undefined>\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Same as ",(0,t.jsx)(e.code,{children:"container.getTaggedAsync"}),", but returns ",(0,t.jsx)(e.code,{children:"Promise<undefined>"})," in the event no bindings are bound to ",(0,t.jsx)(e.code,{children:"serviceIdentifier"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"trygetall",children:"tryGetAll"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"tryGetAll<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, options?: interfaces.GetAllOptions): T[]\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Same as ",(0,t.jsx)(e.code,{children:"container.getAll"}),", but returns ",(0,t.jsx)(e.code,{children:"[]"})," in the event no bindings are bound to ",(0,t.jsx)(e.code,{children:"serviceIdentifier"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"trygetallasync",children:"tryGetAllAsync"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"tryGetAllAsync<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, options?: interfaces.GetAllOptions): Promise<T[]>;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Same as ",(0,t.jsx)(e.code,{children:"container.getAllAsync"}),", but returns ",(0,t.jsx)(e.code,{children:"Promise<[]>"})," in the event no bindings are bound to ",(0,t.jsx)(e.code,{children:"serviceIdentifier"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"trygetallnamed",children:"tryGetAllNamed"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"tryGetAllNamed<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, named: string | number | symbol): T[];\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Same as ",(0,t.jsx)(e.code,{children:"container.getAllNamed"}),", but returns ",(0,t.jsx)(e.code,{children:"[]"})," in the event no bindings are bound to ",(0,t.jsx)(e.code,{children:"serviceIdentifier"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"trygetallnamedasync",children:"tryGetAllNamedAsync"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"tryGetAllNamedAsync<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, named: string | number | symbol): Promise<T[]>;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Same as ",(0,t.jsx)(e.code,{children:"container.getAllNamedAsync"}),", but returns ",(0,t.jsx)(e.code,{children:"Promise<[]>"})," in the event no bindings are bound to ",(0,t.jsx)(e.code,{children:"serviceIdentifier"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"trygetalltagged",children:"tryGetAllTagged"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"tryGetAllTagged<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, key: string | number | symbol, value: unknown): T[];\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Same as ",(0,t.jsx)(e.code,{children:"container.getAllTagged"}),", but returns ",(0,t.jsx)(e.code,{children:"[]"})," in the event no bindings are bound to ",(0,t.jsx)(e.code,{children:"serviceIdentifier"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"trygetalltaggedasync",children:"tryGetAllTaggedAsync"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"tryGetAllTaggedAsync<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, key: string | number | symbol, value: unknown): Promise<T[]>;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Same as ",(0,t.jsx)(e.code,{children:"container.getAllTaggedAsync"}),", but returns ",(0,t.jsx)(e.code,{children:"Promise<[]>"})," in the event no bindings are bound to ",(0,t.jsx)(e.code,{children:"serviceIdentifier"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"unbind",children:"unbind"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"unbind(serviceIdentifier: interfaces.ServiceIdentifier): void;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Remove all bindings binded in this container to the service identifier.  This will result in the ",(0,t.jsx)(e.a,{href:"/docs/6.x/fundamentals/lifecycle/deactivation",children:"deactivation process"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"unbindasync",children:"unbindAsync"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"unbindAsync(serviceIdentifier: interfaces.ServiceIdentifier<unknown>): Promise<void>;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["This is the asynchronous version of unbind. If any deactivation realated to this service identifier is asynchronous then this method should be used instead of ",(0,t.jsx)(e.code,{children:"container.unbind"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"unbindall",children:"unbindAll"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"unbindAll(): void;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Remove all bindings binded in this container.  This will result in the ",(0,t.jsx)(e.a,{href:"/docs/6.x/fundamentals/lifecycle/deactivation",children:"deactivation process"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"unbindallasync",children:"unbindAllAsync"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"unbindAllAsync(): Promise<void>;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["This is the asynchronous version of unbindAll. If any of the container's deactivations is asynchronous then this method should be used instead of ",(0,t.jsx)(e.code,{children:"container.unbindAll"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"unload",children:"unload"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"unload(...modules: interfaces.ContainerModuleBase[]): void;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Removes bindings and handlers added by the modules. This will result in the ",(0,t.jsx)(e.a,{href:"/docs/6.x/fundamentals/lifecycle/deactivation",children:"deactivation process"}),".\nSee ",(0,t.jsx)(e.a,{href:"/docs/6.x/api/container-module",children:"ContainerModule API docs"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"unloadasync",children:"unloadAsync"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"unloadAsync(...modules: interfaces.ContainerModuleBase[]): Promise<void>;\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Asynchronous version of unload. If any of the container modules's deactivations is asynchronous then this method should be used instead of ",(0,t.jsx)(e.code,{children:"container.unload"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"parent",children:"parent"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"parent: Container | null;\n"})}),"\n",(0,t.jsx)(e.p,{children:"Access the parent container."}),"\n",(0,t.jsx)(e.h2,{id:"id",children:"id"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"id: number;\n"})}),"\n",(0,t.jsx)(e.p,{children:"The container's unique identifier."})]})}function m(n={}){let{wrapper:e}={...(0,r.a)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(u,{...n})}):u(n)}},1449:function(n){n.exports="interface Weapon {\n  damage: number;\n}\n\nexport class Katana implements Weapon {\n  #damage: number = 10;\n\n  public get damage(): number {\n    return this.#damage;\n  }\n\n  public improve(): void {\n    this.#damage += 2;\n  }\n}\n\nconst container: Container = new Container();\ncontainer.bind<Weapon>('Weapon').to(Katana);\ncontainer.onActivation(\n  'Weapon',\n  (_context: interfaces.Context, katana: Katana): Katana | Promise<Katana> => {\n    katana.improve();\n\n    return katana;\n  },\n);\n\n// Katana.damage is 12\nconst katana: Weapon = container.get<Weapon>('Weapon');"},1294:function(n){n.exports="interface Weapon {\n  damage: number;\n}\n\nexport class Katana implements Weapon {\n  readonly #damage: number = 10;\n\n  public get damage(): number {\n    return this.#damage;\n  }\n}\n\nconst container: Container = new Container();\n\ncontainer.bind<Weapon>('Weapon').to(Katana).inSingletonScope();\n\ncontainer.get('Weapon');\n\ncontainer.onDeactivation('Weapon', (weapon: Weapon): void | Promise<void> => {\n  console.log(`Deactivating weapon with damage ${weapon.damage.toString()}`);\n});\n\ncontainer.unbind('Weapon');"}}]);