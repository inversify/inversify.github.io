"use strict";(self.webpackChunk_inversifyjs_inversify_docs_site=self.webpackChunk_inversifyjs_inversify_docs_site||[]).push([["9039"],{1473:function(e){e.exports="@injectable()\nclass Ninja {\n  public katana: Weapon;\n  public shuriken: Weapon | undefined;\n  constructor(\n    @inject('Katana') katana: Weapon,\n    @inject('Shuriken') @optional() shuriken: Weapon | undefined,\n  ) {\n    this.katana = katana;\n    this.shuriken = shuriken;\n  }\n}\n\nconst container: Container = new Container();\ncontainer.bind<Weapon>('Katana').to(Katana);\n\ncontainer.bind(Ninja).toSelf();\n\n// Returns a \"Ninja\" instance with a \"Katana\" katana property and undefined shuriken property.\nconst ninja: Ninja = container.get(Ninja);"},1891:function(e){e.exports="@injectable()\nclass Ninja {\n  @multiInject(weaponServiceId)\n  public readonly weapon!: Weapon[];\n}\n\nconst container: Container = new Container();\n\ncontainer.bind(Ninja).toSelf();\ncontainer.bind(weaponServiceId).to(Katana);\n\nconst ninja: Ninja = container.get(Ninja);\n\n// Returns 10\nconst ninjaWeaponDamage: number | undefined = ninja.weapon[0]?.damage;"},3179:function(e,n,a){a.r(n),a.d(n,{frontMatter:()=>b,default:()=>W,contentTitle:()=>f,assets:()=>v,toc:()=>w,metadata:()=>t});var t=JSON.parse('{"id":"api/decorator","title":"Decorator","description":"This section covers Inversify decorators used to provide class metadata.","source":"@site/docs/api/decorator.mdx","sourceDirName":"api","slug":"/api/decorator","permalink":"/docs/next/api/decorator","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Decorator"},"sidebar":"tutorialSidebar","previous":{"title":"Container Module","permalink":"/docs/next/api/container-module"},"next":{"title":"TypeScript Requirements","permalink":"/docs/next/faq/requirements"}}'),r=a(3112),i=a(7104),o=a(8676),s=a(8890),c=a(3298),l=a(8375),d=a(1891),p=a(3659),u=a(1473),h=a(8868),j=a(694),m=a(6098),g=a(9780),x=a(6272);let b={sidebar_position:4,title:"Decorator"},f="Decorators",v={},w=[{value:"injectable",id:"injectable",level:2},{value:"Parameters",id:"parameters",level:3},{value:"When is injectable mandatory?",id:"when-is-injectable-mandatory",level:3},{value:"inject",id:"inject",level:2},{value:"Example: decorating a class constructor argument",id:"example-decorating-a-class-constructor-argument",level:3},{value:"Example: decorating a property",id:"example-decorating-a-property",level:3},{value:"injectFromBase",id:"injectfrombase",level:2},{value:"Arguments",id:"arguments",level:3},{value:"Example: decorating base class constructor arguments",id:"example-decorating-base-class-constructor-arguments",level:3},{value:"Example: decorating base class properties",id:"example-decorating-base-class-properties",level:3},{value:"multiInject",id:"multiinject",level:2},{value:"Example: decorating a property",id:"example-decorating-a-property-1",level:3},{value:"named",id:"named",level:2},{value:"optional",id:"optional",level:2},{value:"postConstruct",id:"postconstruct",level:2},{value:"preDestroy",id:"predestroy",level:2},{value:"tagged",id:"tagged",level:2},{value:"unmanaged",id:"unmanaged",level:2}];function y(e){let n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"decorators",children:"Decorators"})}),"\n",(0,r.jsx)(n.p,{children:"This section covers Inversify decorators used to provide class metadata."}),"\n",(0,r.jsx)(n.h2,{id:"injectable",children:"injectable"}),"\n",(0,r.jsx)(n.p,{children:"Decorator used to set class metadata so containers can receive class-emitted metadata."}),"\n",(0,r.jsxs)(n.p,{children:["It's highly recommended to annotate every class provided as a service with the ",(0,r.jsx)(n.code,{children:"@injectable"})," decorator. However, it's not mandatory in every single case."]}),"\n",(0,r.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"injectable"})," decorator accepts an optional ",(0,r.jsx)(n.code,{children:"scope"})," parameter that allows you to define the lifecycle of the bound instance:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"@injectable('Singleton') // or 'Transient' or 'Request'\nclass MyService {\n  // ...\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Valid scope values are:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"'Singleton'"}),": The container will create only one instance and will return that instance for all requests."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"'Transient'"}),": The container will create a new instance for each request."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"'Request'"}),": The container will create an instance for each unique request (useful in web applications with request scoping)."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"when-is-injectable-mandatory",children:"When is injectable mandatory?"}),"\n",(0,r.jsx)(n.p,{children:"Whenever class-emitted metadata is expected."}),"\n",(0,r.jsx)(n.p,{children:"Consider the following sample code:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { injectable } from 'inversify';\n\n@injectable()\nclass B {\n  readonly foo: string = 'foo';\n}\n\n@injectable()\nclass A {\n  constructor(public readonly b: B) {}\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["A CommonJS transpilation with the ",(0,r.jsx)(n.a,{href:"https://www.typescriptlang.org/tsconfig/#emitDecoratorMetadata",children:"emitDecoratorMetadata"})," option enabled might look like this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'Object.defineProperty(exports, "__esModule", { value: true });\nconst inversify_1 = require("inversify");\nlet B = class B {\n    foo = \'foo\';\n};\nB = __decorate([\n    (0, inversify_1.injectable)()\n], B);\nlet A = class A {\n    b;\n    constructor(b) {\n        this.b = b;\n    }\n};\nA = __decorate([\n    (0, inversify_1.injectable)(),\n    __metadata("design:paramtypes", [B])\n], A);\n'})}),"\n",(0,r.jsxs)(n.p,{children:["TypeScript emits class metadata if and only if there are any class decorators applied to the target class. If we remove the ",(0,r.jsx)(n.code,{children:"@injectable"})," from ",(0,r.jsx)(n.code,{children:"A"}),", the transpiled code looks very different:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"Object.defineProperty(exports, \"__esModule\", { value: true });\nclass B {\n    foo = 'foo';\n}\nclass A {\n    b;\n    constructor(b) {\n        this.b = b;\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This time, no class metadata is emitted even if the ",(0,r.jsx)(n.code,{children:"emitDecoratorMetadata"})," TypeScript option is enabled, causing trouble at execution time."]}),"\n",(0,r.jsx)(n.h2,{id:"inject",children:"inject"}),"\n",(0,r.jsx)(n.p,{children:"Decorator used to establish a relation between a constructor argument or a class property and a service ID."}),"\n",(0,r.jsxs)(n.p,{children:["When resolving an instance of the class, the target constructor argument or property will be resolved in the same way ",(0,r.jsx)(n.a,{href:"/docs/next/api/container#get",children:"container.get"})," behaves."]}),"\n",(0,r.jsx)(n.h3,{id:"example-decorating-a-class-constructor-argument",children:"Example: decorating a class constructor argument"}),"\n",(0,r.jsx)(x.Z,{language:"ts",children:o}),"\n",(0,r.jsx)(n.h3,{id:"example-decorating-a-property",children:"Example: decorating a property"}),"\n",(0,r.jsx)(x.Z,{language:"ts",children:l}),"\n",(0,r.jsx)(n.h2,{id:"injectfrombase",children:"injectFromBase"}),"\n",(0,r.jsx)(n.p,{children:"Decorator used to inject dependencies from a base class. Child class injections take precedence over base class injections."}),"\n",(0,r.jsx)(n.h3,{id:"arguments",children:"Arguments"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"injectFromBase"})," decorator accepts an optional ",(0,r.jsx)(n.code,{children:"InjectFromBaseOptions"})," object with the following properties:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"extendConstructorArguments"})," (boolean, defaults to true): If true, constructor arguments from the base class will be injected."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"extendProperties"})," (boolean, defaults to true): If true, properties from the base class will be injected."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-decorating-base-class-constructor-arguments",children:"Example: decorating base class constructor arguments"}),"\n",(0,r.jsx)(x.Z,{language:"ts",children:s}),"\n",(0,r.jsx)(n.h3,{id:"example-decorating-base-class-properties",children:"Example: decorating base class properties"}),"\n",(0,r.jsx)(x.Z,{language:"ts",children:c}),"\n",(0,r.jsx)(n.h2,{id:"multiinject",children:"multiInject"}),"\n",(0,r.jsx)(n.p,{children:"Decorator used to establish a relation between a constructor argument or a class property and a service ID."}),"\n",(0,r.jsxs)(n.p,{children:["When resolving an instance of the class, the target constructor argument or property will be resolved in the same way ",(0,r.jsx)(n.a,{href:"/docs/next/api/container#getall",children:"container.getAll"})," behaves."]}),"\n",(0,r.jsx)(n.h3,{id:"example-decorating-a-property-1",children:"Example: decorating a property"}),"\n",(0,r.jsx)(x.Z,{language:"ts",children:d}),"\n",(0,r.jsx)(n.h2,{id:"named",children:"named"}),"\n",(0,r.jsx)(n.p,{children:"Decorator used to establish a relation between a constructor argument or a class property and a metadata name."}),"\n",(0,r.jsx)(x.Z,{language:"ts",children:p}),"\n",(0,r.jsx)(n.h2,{id:"optional",children:"optional"}),"\n",(0,r.jsx)(n.p,{children:"Decorator used to establish that a target constructor argument or property is optional and, therefore, it shall not be resolved if no bindings are found for the associated service ID."}),"\n",(0,r.jsx)(x.Z,{language:"ts",children:u}),"\n",(0,r.jsx)(n.h2,{id:"postconstruct",children:"postConstruct"}),"\n",(0,r.jsxs)(n.p,{children:["Decorator used to establish an activation handler for the target class. Refer to the ",(0,r.jsx)(n.a,{href:"/docs/next/fundamentals/lifecycle/activation",children:"docs"})," for more information."]}),"\n",(0,r.jsx)(x.Z,{language:"ts",children:h}),"\n",(0,r.jsx)(n.h2,{id:"predestroy",children:"preDestroy"}),"\n",(0,r.jsxs)(n.p,{children:["Decorator used to establish a deactivation handler for the target class. Refer to the ",(0,r.jsx)(n.a,{href:"/docs/next/fundamentals/lifecycle/deactivation",children:"docs"})," for more information."]}),"\n",(0,r.jsx)(x.Z,{language:"ts",children:j}),"\n",(0,r.jsx)(n.h2,{id:"tagged",children:"tagged"}),"\n",(0,r.jsx)(n.p,{children:"Decorator used to establish a relation between a constructor argument or a class property and a metadata tag."}),"\n",(0,r.jsx)(x.Z,{language:"ts",children:m}),"\n",(0,r.jsx)(n.h2,{id:"unmanaged",children:"unmanaged"}),"\n",(0,r.jsx)(n.p,{children:"Decorator used to establish that Inversify should not inject the target constructor argument or property whatsoever."}),"\n",(0,r.jsx)(x.Z,{language:"ts",children:g})]})}function W(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(y,{...e})}):y(e)}},3298:function(e){e.exports="type Weapon = unknown;\n\n@injectable()\nabstract class BaseSoldier {\n  @inject('Weapon')\n  public weapon: Weapon;\n}\n\n@injectable()\n@injectFromBase({\n  extendConstructorArguments: false,\n  extendProperties: true,\n})\nclass Soldier extends BaseSoldier {}\n\n// Returns a soldier with a weapon\nconst soldier: Soldier = container.get(Soldier);"},3659:function(e){e.exports="@injectable()\nclass Ninja {\n  public katana: Weapon;\n  public shuriken: Weapon;\n  constructor(\n    @inject('Weapon') @named('melee') katana: Weapon,\n    @inject('Weapon') @named('ranged') shuriken: Weapon,\n  ) {\n    this.katana = katana;\n    this.shuriken = shuriken;\n  }\n}\n\nconst container: Container = new Container();\ncontainer.bind<Weapon>('Weapon').to(Katana).whenNamed('melee');\ncontainer.bind<Weapon>('Weapon').to(Shuriken).whenNamed('ranged');\ncontainer.bind(Ninja).toSelf();\n\nconst ninja: Ninja = container.get(Ninja);"},6098:function(e){e.exports="@injectable()\nclass Ninja {\n  public katana: Weapon;\n  public shuriken: Weapon;\n  constructor(\n    @inject('Weapon') @tagged('weaponKind', 'melee') katana: Weapon,\n    @inject('Weapon') @tagged('weaponKind', 'ranged') shuriken: Weapon,\n  ) {\n    this.katana = katana;\n    this.shuriken = shuriken;\n  }\n}\n\nconst container: Container = new Container();\ncontainer.bind<Weapon>('Weapon').to(Katana).whenTagged('weaponKind', 'melee');\ncontainer\n  .bind<Weapon>('Weapon')\n  .to(Shuriken)\n  .whenTagged('weaponKind', 'ranged');\ncontainer.bind(Ninja).toSelf();\n\nconst ninja: Ninja = container.get(Ninja);"},694:function(e){e.exports="interface Weapon {\n  damage: number;\n}\n\nclass Katana implements Weapon {\n  readonly #damage: number = 10;\n\n  public get damage(): number {\n    return this.#damage;\n  }\n\n  @preDestroy()\n  public onDeactivation(): void {\n    console.log(`Deactivating weapon with damage ${this.damage.toString()}`);\n  }\n}\n\nconst container: Container = new Container();\n\ncontainer.bind<Weapon>('Weapon').to(Katana).inSingletonScope();\n\ncontainer.get('Weapon');\n\nawait container.unbind('Weapon');"},8375:function(e){e.exports="@injectable()\nclass Ninja {\n  @inject(weaponServiceId)\n  public readonly weapon!: Weapon;\n}\n\nconst container: Container = new Container();\n\ncontainer.bind(Ninja).toSelf();\ncontainer.bind(weaponServiceId).to(Katana);\n\nconst ninja: Ninja = container.get(Ninja);\n\n// Returns 10\nconst ninjaWeaponDamage: number = ninja.weapon.damage;"},8676:function(e){e.exports="@injectable()\nclass Ninja {\n  constructor(\n    @inject(weaponServiceId)\n    public readonly weapon: Weapon,\n  ) {}\n}\n\nconst container: Container = new Container();\n\ncontainer.bind(Ninja).toSelf();\ncontainer.bind(weaponServiceId).to(Katana);\n\nconst ninja: Ninja = container.get(Ninja);\n\n// Returns 10\nconst ninjaWeaponDamage: number = ninja.weapon.damage;"},8868:function(e){e.exports="interface Weapon {\n  damage: number;\n}\n\nexport class Katana implements Weapon {\n  #damage: number = 10;\n\n  public get damage(): number {\n    return this.#damage;\n  }\n\n  @postConstruct()\n  public improve(): void {\n    this.#damage += 2;\n  }\n}\n\nconst container: Container = new Container();\ncontainer.bind<Weapon>('Weapon').to(Katana);\n\n// Katana.damage is 12\nconst katana: Weapon = container.get<Weapon>('Weapon');"},8890:function(e){e.exports="type Weapon = unknown;\n\n@injectable()\nabstract class BaseSoldier {\n  public weapon: Weapon;\n  constructor(@inject('Weapon') weapon: Weapon) {\n    this.weapon = weapon;\n  }\n}\n\n@injectable()\n@injectFromBase({\n  extendConstructorArguments: true,\n  extendProperties: false,\n})\nclass Soldier extends BaseSoldier {}\n\n// Returns a soldier with a weapon\nconst soldier: Soldier = container.get(Soldier);"},9780:function(e){e.exports="import { Container, injectable, unmanaged } from 'inversify';\n\n@injectable()\nclass Base {\n  public prop: string;\n  constructor(@unmanaged() arg: string) {\n    this.prop = arg;\n  }\n}\n\n@injectable()\nclass Derived extends Base {\n  constructor() {\n    super('inherited-value');\n  }\n}\n\nconst container: Container = new Container();\n\ncontainer.bind(Derived).toSelf();\n\nconst derived: Derived = container.get(Derived);\n\n// Returns 'inherited-value'\nconst derivedProp: string = derived.prop;"}}]);