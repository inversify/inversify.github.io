"use strict";(self.webpackChunk_inversifyjs_inversify_docs_site=self.webpackChunk_inversifyjs_inversify_docs_site||[]).push([["1481"],{1822:function(n,e,i){i.r(e),i.d(e,{frontMatter:()=>s,toc:()=>l,default:()=>p,metadata:()=>a,assets:()=>d,contentTitle:()=>c});var a=JSON.parse('{"id":"fundamentals/di-hierarchy","title":"DI Hierarchy","description":"InversifyJS is a popular library for implementing inversion of control (IoC) and dependency injection (DI) in TypeScript applications. It supports hierarchical dependency injection, which can be a powerful tool in complex applications.","source":"@site/versioned_docs/version-6.x/fundamentals/di-hierarchy.mdx","sourceDirName":"fundamentals","slug":"/fundamentals/di-hierarchy","permalink":"/docs/6.x/fundamentals/di-hierarchy","draft":false,"unlisted":false,"tags":[],"version":"6.x","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"DI Hierarchy"},"sidebar":"tutorialSidebar","previous":{"title":"Binding","permalink":"/docs/6.x/fundamentals/binding"},"next":{"title":"Activation","permalink":"/docs/6.x/fundamentals/lifecycle/activation"}}'),t=i(6820),r=i(7588),o=i(9811);let s={sidebar_position:2,title:"DI Hierarchy"},c="DI Hierarchy",d={},l=[];function h(n){let e={admonition:"admonition",code:"code",h1:"h1",header:"header",p:"p",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"di-hierarchy",children:"DI Hierarchy"})}),"\n",(0,t.jsx)(e.p,{children:"InversifyJS is a popular library for implementing inversion of control (IoC) and dependency injection (DI) in TypeScript applications. It supports hierarchical dependency injection, which can be a powerful tool in complex applications."}),"\n",(0,t.jsx)(e.p,{children:"With InversifyJS's hierarchical injection system, you can create a hierarchy of containers where each container can have a parent container. This allows for better organization and separation of concerns in your application."}),"\n",(0,t.jsx)(e.p,{children:"When a dependency needs to be injected, InversifyJS starts by looking in the current container for a binding. If the binding is not found, it moves up the hierarchy to the parent container and continues the search. This process continues until a binding is found or the top-level parent container is reached."}),"\n",(0,t.jsx)(e.admonition,{title:"Binding overrides",type:"warning",children:(0,t.jsx)(e.p,{children:"Found bindings might override ancestor bindings even if their constraints are not met. For example, if a named binding is found in the child container for the requested service, that binding overrides parent bindings even if this binding is later discarded in a non-named resolution request."})}),"\n",(0,t.jsxs)(e.admonition,{title:"DI hierarchies and cached bindings",type:"warning",children:[(0,t.jsx)(e.p,{children:"When using hierarchical injection, be aware that cached bindings from the first resolution will be used for subsequent resolution, even if the call comes from another child container."}),(0,t.jsx)(o.A,{language:"ts",children:"@injectable()\nclass Samurai {\n  constructor(\n    @inject(Katana)\n    public katana: Katana,\n  ) {}\n}\n\nconst parentContainer: Container = new Container();\nparentContainer.bind(Samurai).toSelf().inSingletonScope();\nparentContainer.bind(Katana).toSelf();\n\nconst childContainer: Container = parentContainer.createChild();\nchildContainer.bind(Katana).to(LegendaryKatana);\n\n// The result of this resolution will be cached in the samurai binding\nchildContainer.get(Samurai);\n\n// This samurai will have a LegendaryKatana injected\nconst samurai: Samurai = parentContainer.get(Samurai);"}),(0,t.jsxs)(e.p,{children:["If this behaviour is unwanted, consider using ",(0,t.jsx)(e.code,{children:"ContainerModule"})," instead. This way, you can load it in both containers. Different containers will have different binding and therefore different cached values."]})]}),"\n",(0,t.jsx)(e.p,{children:"By using InversifyJS's hierarchical injection system, you can easily manage complex dependencies and keep your code clean and modular. It provides a flexible and scalable solution for handling dependencies in your TypeScript applications."}),"\n",(0,t.jsx)(o.A,{language:"ts",children:"class Katana {}\n\nconst parentContainer: Container = new Container();\nparentContainer.bind(weaponIdentifier).to(Katana);\n\nconst childContainer: Container = parentContainer.createChild();\n\nconst katana: Katana = childContainer.get(weaponIdentifier);"})]})}function p(n={}){let{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(h,{...n})}):h(n)}}}]);