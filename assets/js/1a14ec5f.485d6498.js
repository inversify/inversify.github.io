"use strict";(self.webpackChunk_inversifyjs_inversify_docs_site=self.webpackChunk_inversifyjs_inversify_docs_site||[]).push([["7800"],{1981:function(e,i,n){n.r(i),n.d(i,{frontMatter:()=>a,toc:()=>v,default:()=>f,metadata:()=>r,assets:()=>l,contentTitle:()=>o});var r=JSON.parse('{"id":"api/service-identifier","title":"ServiceIdentifier","description":"Overview","source":"@site/versioned_docs/version-7.x/api/service-identifier.mdx","sourceDirName":"api","slug":"/api/service-identifier","permalink":"/docs/api/service-identifier","draft":false,"unlisted":false,"tags":[],"version":"7.x","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"title":"ServiceIdentifier"},"sidebar":"tutorialSidebar","previous":{"title":"LazyServiceIdentifier","permalink":"/docs/api/lazy-service-identifier"},"next":{"title":"TypeScript Requirements","permalink":"/docs/faq/requirements"}}'),s=n(6820),t=n(7588),c=n(2810),d=n(9811);let a={sidebar_position:7,title:"ServiceIdentifier"},o="ServiceIdentifier",l={},v=[{value:"Overview",id:"overview",level:2},{value:"Definition",id:"definition",level:2},{value:"Usage",id:"usage",level:2},{value:"Examples",id:"examples",level:3}];function h(e){let i={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"serviceidentifier",children:"ServiceIdentifier"})}),"\n",(0,s.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"ServiceIdentifier"})," is a fundamental type that identifies services within the InversifyJS dependency injection container. It serves as a key for registering, locating, and retrieving services, acting as a bridge between service registration and resolution."]}),"\n",(0,s.jsx)(i.h2,{id:"definition",children:"Definition"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"ServiceIdentifier"})," is a union type that can be one of:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-typescript",children:"type ServiceIdentifier<TInstance = unknown> =\n  | string\n  | symbol\n  | Newable<TInstance>\n  | AbstractNewable<TInstance>;\n"})}),"\n",(0,s.jsxs)(i.p,{children:["Where ",(0,s.jsx)(i.code,{children:"Newable"})," is defined as:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-typescript",children:"type Newable<\n  TInstance = unknown,\n  TArgs extends unknown[] = any[],\n> = new (...args: TArgs) => TInstance;\n"})}),"\n",(0,s.jsx)(i.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"ServiceIdentifier"})," is used throughout the InversifyJS API for:"]}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Service Registration"}),": Binding services to the container"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Service Resolution"}),": Retrieving services from the container"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Service Configuration"}),": Setting activation/deactivation handlers"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(d.A,{language:"ts",children:c}),"\n",(0,s.jsx)(i.admonition,{title:"Type Inference support",type:"info",children:(0,s.jsxs)(i.p,{children:["When using generics with ",(0,s.jsx)(i.code,{children:"ServiceIdentifier<T>"}),", TypeScript can infer the resolved type. In the example above, ",(0,s.jsx)(i.code,{children:"firstUserService"})," is automatically typed as ",(0,s.jsx)(i.code,{children:"UserService"})," because ",(0,s.jsx)(i.code,{children:"UserService"})," is inferred as ",(0,s.jsx)(i.code,{children:"ServiceIdentifier<UserService>"}),"."]})}),"\n",(0,s.jsxs)(i.admonition,{title:"Assignment reduced type",type:"warning",children:[(0,s.jsx)(i.p,{children:'In TypeScript, when a variable annotated with a union is assigned, the actual initial type of that variable becomes "an assignment reduced type".'}),(0,s.jsxs)(i.p,{children:["In the example above, ",(0,s.jsx)(i.code,{children:"userServiceId"})," is automatically reduced as ",(0,s.jsx)(i.code,{children:"symbol"})," and therefore, ",(0,s.jsx)(i.code,{children:"firstUserService"})," is typed as ",(0,s.jsx)(i.code,{children:"unknown"}),".\nUsing a casting prevents this reduction and maintains the original type. Consider ",(0,s.jsx)(i.code,{children:"fourthUserService"})," as an example."]})]})]})}function f(e={}){let{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},2810:function(e){e.exports="container.bind(UserService).toSelf();\n\n// Using a string as a service identifier\ncontainer.bind('IUserService').to(UserService);\n\n// Using a symbol as a service identifier\nconst userServiceId: ServiceIdentifier<UserService> = Symbol.for('UserService');\nconst castedUserServiceId: ServiceIdentifier<UserService> = Symbol.for(\n  'UserService',\n) as ServiceIdentifier<UserService>;\ncontainer.bind(userServiceId).to(UserService);\n\n// Resolving with a class identifier\nconst firstUserService = container.get(UserService);\n\n// Resolving with a string identifier\nconst secondUserService = container.get('IUserService');\n\n// Resolving with a symbol identifier\nconst thirdUserService = container.get(userServiceId);\n\n// Resolving with a symbol identifier\nconst fourthUserService = container.get(castedUserServiceId);"}}]);