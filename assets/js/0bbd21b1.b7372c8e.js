"use strict";(self.webpackChunk_inversifyjs_inversify_docs_site=self.webpackChunk_inversifyjs_inversify_docs_site||[]).push([["4817"],{9481:function(e,n,t){t.r(n),t.d(n,{frontMatter:()=>a,toc:()=>d,default:()=>h,metadata:()=>i,assets:()=>c,contentTitle:()=>o});var i=JSON.parse('{"id":"fundamentals/inheritance","title":"Inheritance","description":"Inheritance can be achieved relying on the @injectFromBase decorator. This decorator allows you to inject dependencies from the base class. Refer to the API documentation for more information.","source":"@site/docs/fundamentals/inheritance.mdx","sourceDirName":"fundamentals","slug":"/fundamentals/inheritance","permalink":"/docs/next/fundamentals/inheritance","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Inheritance"},"sidebar":"tutorialSidebar","previous":{"title":"Deactivation","permalink":"/docs/next/fundamentals/lifecycle/deactivation"},"next":{"title":"Plugins","permalink":"/docs/next/fundamentals/plugins"}}'),s=t(4076),r=t(9221);let a={sidebar_position:4,title:"Inheritance"},o="Inheritance",c={},d=[{value:"Motivation",id:"motivation",level:2}];function l(e){let n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"inheritance",children:"Inheritance"})}),"\n",(0,s.jsxs)(n.p,{children:["Inheritance can be achieved relying on the ",(0,s.jsx)(n.code,{children:"@injectFromBase"})," decorator. This decorator allows you to inject dependencies from the base class. Refer to the ",(0,s.jsx)(n.a,{href:"/docs/next/api/decorator#injectfrombase",children:"API documentation"})," for more information."]}),"\n",(0,s.jsxs)(n.p,{children:["Previous versions of inversify used to provide implicitly injection inheritance. However, this approach was deprecated in favor of the ",(0,s.jsx)(n.code,{children:"@injectFromBase"})," decorator."]}),"\n",(0,s.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,s.jsxs)(n.p,{children:["Decorators are not designed to be inherited. Class inheritance doesn't play well with the former approach. The ",(0,s.jsx)(n.code,{children:"@injectFromBase"})," decorator allows the developer whether or not decoration inheritance should be provided."]}),"\n",(0,s.jsx)(n.p,{children:"In exchange of implicit inheritance, previous inversify versions performed multiple checks to ensure every class argument was injected. Some edge case scenarios forced to declare unmanaged parent constructor arguments so inversify could bypass these checks."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"It makes no sense to declare parent constructor argument injections in cases in which the child class requires no injection at all:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"class BaseShape {\n  kind: string;\n\n  // We should not inject the kind in the parent class\n  constructor(kind: string) {\n    this.kind = kind;\n  }\n}\n\nclass SquareShape extends BaseShape {\n  constructor() {\n    super('square');\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"It makes no sense to declare parent constructor argument injections in cases in which the child class arguments don't match the parent class arguments:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"class BaseShape {\n  // We should not inject kind nor sides, for they are likely to be in the wrong order in the child class\n  constructor(\n    public readonly kind: string,\n    public readonly sides: number,\n  ) {}\n}\n\nclass RegularPolygonShape extends BaseShape {\n  constructor(sides: number) {\n    super('RegularPolygon', sides);\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The current approach allows the developer to decide whether or not to inherit the parent class injections relying on the ",(0,s.jsx)(n.code,{children:"@injectFromBase"})," decorator."]})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);