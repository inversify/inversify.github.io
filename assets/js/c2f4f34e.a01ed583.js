"use strict";(self.webpackChunk_inversifyjs_inversify_docs_site=self.webpackChunk_inversifyjs_inversify_docs_site||[]).push([["2307"],{3231:function(e,n,a){a.r(n),a.d(n,{frontMatter:()=>v,toc:()=>W,default:()=>k,metadata:()=>t,assets:()=>y,contentTitle:()=>w});var t=JSON.parse('{"id":"api/decorator","title":"Decorator","description":"This section covers Inversify decorators used to provide class metadata.","source":"@site/versioned_docs/version-7.x/api/decorator.mdx","sourceDirName":"api","slug":"/api/decorator","permalink":"/docs/api/decorator","draft":false,"unlisted":false,"tags":[],"version":"7.x","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Decorator"},"sidebar":"tutorialSidebar","previous":{"title":"Container Module","permalink":"/docs/api/container-module"},"next":{"title":"decorate","permalink":"/docs/api/decorate"}}'),r=a(9970),o=a(7245),i=a(3157),s=a(4133),c=a(3124),l=a(8933),d=a(9988),p=a(6381),h=a(3412),u=a(7776),j=a(3953),m=a(646),x=a(8708),g=a(1637),b=a(3838),f=a(938);let v={sidebar_position:4,title:"Decorator"},w="Decorators",y={},W=[{value:"injectable",id:"injectable",level:2},{value:"Parameters",id:"parameters",level:3},{value:"When is injectable mandatory?",id:"when-is-injectable-mandatory",level:3},{value:"inject",id:"inject",level:2},{value:"Example: decorating a class constructor argument",id:"example-decorating-a-class-constructor-argument",level:3},{value:"Example: decorating a property",id:"example-decorating-a-property",level:3},{value:"injectFromBase",id:"injectfrombase",level:2},{value:"Parameters",id:"parameters-1",level:3},{value:"Example: decorating base class constructor arguments",id:"example-decorating-base-class-constructor-arguments",level:3},{value:"Example: decorating base class properties",id:"example-decorating-base-class-properties",level:3},{value:"injectFromHierarchy",id:"injectfromhierarchy",level:2},{value:"Parameters",id:"parameters-2",level:3},{value:"Example: decorating hierarchy constructor arguments",id:"example-decorating-hierarchy-constructor-arguments",level:3},{value:"Example: decorating hierarchy properties",id:"example-decorating-hierarchy-properties",level:3},{value:"multiInject",id:"multiinject",level:2},{value:"Parameters",id:"parameters-3",level:3},{value:"Example: decorating a property",id:"example-decorating-a-property-1",level:3},{value:"named",id:"named",level:2},{value:"optional",id:"optional",level:2},{value:"postConstruct",id:"postconstruct",level:2},{value:"preDestroy",id:"predestroy",level:2},{value:"tagged",id:"tagged",level:2},{value:"unmanaged",id:"unmanaged",level:2}];function S(e){let n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"decorators",children:"Decorators"})}),"\n",(0,r.jsx)(n.p,{children:"This section covers Inversify decorators used to provide class metadata."}),"\n",(0,r.jsx)(n.h2,{id:"injectable",children:"injectable"}),"\n",(0,r.jsx)(n.p,{children:"Decorator used to set class metadata so containers can receive class-emitted metadata."}),"\n",(0,r.jsxs)(n.p,{children:["It's highly recommended to annotate every class provided as a service with the ",(0,r.jsx)(n.code,{children:"@injectable"})," decorator. However, it's not mandatory in every single case."]}),"\n",(0,r.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"injectable"})," decorator accepts an optional ",(0,r.jsx)(n.code,{children:"scope"})," parameter that allows you to define the lifecycle of the bound instance:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"@injectable('Singleton') // or 'Transient' or 'Request'\nclass MyService {\n  // ...\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Valid scope values are:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"'Singleton'"}),": The container will create only one instance and will return that instance for all requests."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"'Transient'"}),": The container will create a new instance for each request."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"'Request'"}),": The container will create an instance for each unique request (useful in web applications with request scoping)."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"when-is-injectable-mandatory",children:"When is injectable mandatory?"}),"\n",(0,r.jsx)(n.p,{children:"Whenever class-emitted metadata is expected."}),"\n",(0,r.jsx)(n.p,{children:"Consider the following sample code:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { injectable } from 'inversify';\n\n@injectable()\nclass B {\n  readonly foo: string = 'foo';\n}\n\n@injectable()\nclass A {\n  constructor(public readonly b: B) {}\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["A CommonJS transpilation with the ",(0,r.jsx)(n.a,{href:"https://www.typescriptlang.org/tsconfig/#emitDecoratorMetadata",children:"emitDecoratorMetadata"})," option enabled might look like this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'Object.defineProperty(exports, "__esModule", { value: true });\nconst inversify_1 = require("inversify");\nlet B = class B {\n    foo = \'foo\';\n};\nB = __decorate([\n    (0, inversify_1.injectable)()\n], B);\nlet A = class A {\n    b;\n    constructor(b) {\n        this.b = b;\n    }\n};\nA = __decorate([\n    (0, inversify_1.injectable)(),\n    __metadata("design:paramtypes", [B])\n], A);\n'})}),"\n",(0,r.jsxs)(n.p,{children:["TypeScript emits class metadata if and only if there are any class decorators applied to the target class. If we remove the ",(0,r.jsx)(n.code,{children:"@injectable"})," from ",(0,r.jsx)(n.code,{children:"A"}),", the transpiled code looks very different:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"Object.defineProperty(exports, \"__esModule\", { value: true });\nclass B {\n    foo = 'foo';\n}\nclass A {\n    b;\n    constructor(b) {\n        this.b = b;\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This time, no class metadata is emitted even if the ",(0,r.jsx)(n.code,{children:"emitDecoratorMetadata"})," TypeScript option is enabled, causing trouble at execution time."]}),"\n",(0,r.jsx)(n.h2,{id:"inject",children:"inject"}),"\n",(0,r.jsx)(n.p,{children:"Decorator used to establish a relation between a constructor argument or a class property and a service ID."}),"\n",(0,r.jsxs)(n.p,{children:["When resolving an instance of the class, the target constructor argument or property will be resolved in the same way ",(0,r.jsx)(n.a,{href:"/docs/api/container#get",children:"container.get"})," behaves."]}),"\n",(0,r.jsx)(n.h3,{id:"example-decorating-a-class-constructor-argument",children:"Example: decorating a class constructor argument"}),"\n",(0,r.jsx)(f.A,{language:"ts",children:i}),"\n",(0,r.jsx)(n.h3,{id:"example-decorating-a-property",children:"Example: decorating a property"}),"\n",(0,r.jsx)(f.A,{language:"ts",children:p}),"\n",(0,r.jsx)(n.h2,{id:"injectfrombase",children:"injectFromBase"}),"\n",(0,r.jsx)(n.p,{children:"Decorator used to inject dependencies from a base class. Child class injections take precedence over base class injections."}),"\n",(0,r.jsx)(n.h3,{id:"parameters-1",children:"Parameters"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"injectFromBase"})," decorator accepts an optional ",(0,r.jsx)(n.code,{children:"InjectFromBaseOptions"})," object with the following properties:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"extendConstructorArguments"})," (boolean, defaults to true): If true, constructor arguments from the base class will be injected."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"extendProperties"})," (boolean, defaults to true): If true, properties from the base class will be injected."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"lifecycle"})," (object, optional): Lifecycle options for extending lifecycle methods from the base class:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"extendPostConstructMethods"})," (boolean, defaults to true): If true, post-construct methods from the base class will be extended."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"extendPreDestroyMethods"})," (boolean, defaults to true): If true, pre-destroy methods from the base class will be extended."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-decorating-base-class-constructor-arguments",children:"Example: decorating base class constructor arguments"}),"\n",(0,r.jsx)(f.A,{language:"ts",children:s}),"\n",(0,r.jsx)(n.h3,{id:"example-decorating-base-class-properties",children:"Example: decorating base class properties"}),"\n",(0,r.jsx)(f.A,{language:"ts",children:c}),"\n",(0,r.jsx)(n.h2,{id:"injectfromhierarchy",children:"injectFromHierarchy"}),"\n",(0,r.jsx)(n.p,{children:"Decorator used to inject dependencies from the full class hierarchy (all ancestors). The injection is applied top-down (from the farthest ancestor to the closest base)."}),"\n",(0,r.jsx)(n.h3,{id:"parameters-2",children:"Parameters"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"injectFromHierarchy"})," decorator accepts an optional ",(0,r.jsx)(n.code,{children:"InjectFromHierarchyOptions"})," object with the following properties:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"extendConstructorArguments"})," (boolean, defaults to true): If true, constructor arguments from all ancestors will be injected."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"extendProperties"})," (boolean, defaults to true): If true, properties from all ancestors will be injected."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"lifecycle"})," (object, optional): Lifecycle options for extending lifecycle methods from the hierarchy:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"extendPostConstructMethods"})," (boolean, defaults to true): If true, post-construct methods from all ancestors will be extended."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"extendPreDestroyMethods"})," (boolean, defaults to true): If true, pre-destroy methods from all ancestors will be extended."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-decorating-hierarchy-constructor-arguments",children:"Example: decorating hierarchy constructor arguments"}),"\n",(0,r.jsx)(f.A,{language:"ts",children:l}),"\n",(0,r.jsx)(n.h3,{id:"example-decorating-hierarchy-properties",children:"Example: decorating hierarchy properties"}),"\n",(0,r.jsx)(f.A,{language:"ts",children:d}),"\n",(0,r.jsx)(n.h2,{id:"multiinject",children:"multiInject"}),"\n",(0,r.jsx)(n.p,{children:"Decorator used to establish a relation between a constructor argument or a class property and a service ID."}),"\n",(0,r.jsxs)(n.p,{children:["When resolving an instance of the class, the target constructor argument or property will be resolved in the same way ",(0,r.jsx)(n.a,{href:"/docs/api/container#getall",children:"container.getAll"})," behaves."]}),"\n",(0,r.jsx)(n.h3,{id:"parameters-3",children:"Parameters"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"multiInject"})," decorator accepts an optional ",(0,r.jsx)(n.code,{children:"MultiInjectOptions"})," object with the following properties:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"chained"})," (boolean): Option to enable chained resolution across container hierarchies. Refer to the ",(0,r.jsx)(n.a,{href:"/docs/fundamentals/di-hierarchy#chained-resolution-mode",children:"docs"})," for more information."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-decorating-a-property-1",children:"Example: decorating a property"}),"\n",(0,r.jsx)(f.A,{language:"ts",children:h}),"\n",(0,r.jsx)(n.h2,{id:"named",children:"named"}),"\n",(0,r.jsx)(n.p,{children:"Decorator used to establish a relation between a constructor argument or a class property and a metadata name."}),"\n",(0,r.jsx)(f.A,{language:"ts",children:u}),"\n",(0,r.jsx)(n.h2,{id:"optional",children:"optional"}),"\n",(0,r.jsx)(n.p,{children:"Decorator used to establish that a target constructor argument or property is optional and, therefore, it shall not be resolved if no bindings are found for the associated service ID."}),"\n",(0,r.jsx)(f.A,{language:"ts",children:j}),"\n",(0,r.jsx)(n.h2,{id:"postconstruct",children:"postConstruct"}),"\n",(0,r.jsxs)(n.p,{children:["Decorator used to establish an activation handler for the target class. Refer to the ",(0,r.jsx)(n.a,{href:"/docs/fundamentals/lifecycle/activation",children:"docs"})," for more information."]}),"\n",(0,r.jsx)(f.A,{language:"ts",children:m}),"\n",(0,r.jsx)(n.h2,{id:"predestroy",children:"preDestroy"}),"\n",(0,r.jsxs)(n.p,{children:["Decorator used to establish a deactivation handler for the target class. Refer to the ",(0,r.jsx)(n.a,{href:"/docs/fundamentals/lifecycle/deactivation",children:"docs"})," for more information."]}),"\n",(0,r.jsx)(f.A,{language:"ts",children:x}),"\n",(0,r.jsx)(n.h2,{id:"tagged",children:"tagged"}),"\n",(0,r.jsx)(n.p,{children:"Decorator used to establish a relation between a constructor argument or a class property and a metadata tag."}),"\n",(0,r.jsx)(f.A,{language:"ts",children:g}),"\n",(0,r.jsx)(n.h2,{id:"unmanaged",children:"unmanaged"}),"\n",(0,r.jsx)(n.p,{children:"Decorator used to establish that Inversify should not inject the target constructor argument or property whatsoever."}),"\n",(0,r.jsx)(f.A,{language:"ts",children:b})]})}function k(e={}){let{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(S,{...e})}):S(e)}},3157:function(e){e.exports="@injectable()\nclass Ninja {\n  constructor(\n    @inject(weaponServiceId)\n    public readonly weapon: Weapon,\n  ) {}\n}\n\nconst container: Container = new Container();\n\ncontainer.bind(Ninja).toSelf();\ncontainer.bind(weaponServiceId).to(Katana);\n\nconst ninja: Ninja = container.get(Ninja);\n\n// Returns 10\nconst ninjaWeaponDamage: number = ninja.weapon.damage;"},4133:function(e){e.exports="type Weapon = unknown;\n\n@injectable()\nabstract class BaseSoldier {\n  public weapon: Weapon;\n  constructor(@inject('Weapon') weapon: Weapon) {\n    this.weapon = weapon;\n  }\n}\n\n@injectable()\n@injectFromBase({\n  extendConstructorArguments: true,\n  extendProperties: false,\n})\nclass Soldier extends BaseSoldier {}\n\n// Returns a soldier with a weapon\nconst soldier: Soldier = container.get(Soldier);"},3124:function(e){e.exports="type Weapon = unknown;\n\n@injectable()\nabstract class BaseSoldier {\n  @inject('Weapon')\n  public weapon: Weapon;\n}\n\n@injectable()\n@injectFromBase({\n  extendConstructorArguments: false,\n  extendProperties: true,\n})\nclass Soldier extends BaseSoldier {}\n\n// Returns a soldier with a weapon\nconst soldier: Soldier = container.get(Soldier);"},8933:function(e){e.exports="type Weapon = unknown;\n\n@injectable()\nabstract class BaseSoldier {\n  public weapon: Weapon;\n  constructor(@inject('Weapon') weapon: Weapon) {\n    this.weapon = weapon;\n  }\n}\n\n@injectable()\nabstract class IntermediateSoldier extends BaseSoldier {}\n\n@injectable()\n@injectFromHierarchy({\n  extendConstructorArguments: true,\n  extendProperties: false,\n})\nclass Soldier extends IntermediateSoldier {}\n\n// Returns a soldier with a weapon\nconst soldier: Soldier = container.get(Soldier);"},9988:function(e){e.exports="type Weapon = unknown;\n\n@injectable()\nabstract class BaseSoldier {\n  @inject('Weapon')\n  public weapon: Weapon;\n}\n\n@injectable()\nabstract class IntermediateSoldier extends BaseSoldier {}\n\n@injectable()\n@injectFromHierarchy({\n  extendConstructorArguments: false,\n  extendProperties: true,\n})\nclass Soldier extends IntermediateSoldier {}\n\n// Returns a soldier with a weapon\nconst soldier: Soldier = container.get(Soldier);"},6381:function(e){e.exports="@injectable()\nclass Ninja {\n  @inject(weaponServiceId)\n  public readonly weapon!: Weapon;\n}\n\nconst container: Container = new Container();\n\ncontainer.bind(Ninja).toSelf();\ncontainer.bind(weaponServiceId).to(Katana);\n\nconst ninja: Ninja = container.get(Ninja);\n\n// Returns 10\nconst ninjaWeaponDamage: number = ninja.weapon.damage;"},3412:function(e){e.exports="@injectable()\nclass Ninja {\n  @multiInject(weaponServiceId)\n  public readonly weapon!: Weapon[];\n}\n\nconst container: Container = new Container();\n\ncontainer.bind(Ninja).toSelf();\ncontainer.bind(weaponServiceId).to(Katana);\n\nconst ninja: Ninja = container.get(Ninja);\n\n// Returns 10\nconst ninjaWeaponDamage: number | undefined = ninja.weapon[0]?.damage;"},7776:function(e){e.exports="@injectable()\nclass Ninja {\n  public katana: Weapon;\n  public shuriken: Weapon;\n  constructor(\n    @inject('Weapon') @named('melee') katana: Weapon,\n    @inject('Weapon') @named('ranged') shuriken: Weapon,\n  ) {\n    this.katana = katana;\n    this.shuriken = shuriken;\n  }\n}\n\nconst container: Container = new Container();\ncontainer.bind<Weapon>('Weapon').to(Katana).whenNamed('melee');\ncontainer.bind<Weapon>('Weapon').to(Shuriken).whenNamed('ranged');\ncontainer.bind(Ninja).toSelf();\n\nconst ninja: Ninja = container.get(Ninja);"},3953:function(e){e.exports="@injectable()\nclass Ninja {\n  public katana: Weapon;\n  public shuriken: Weapon | undefined;\n  constructor(\n    @inject('Katana') katana: Weapon,\n    @inject('Shuriken') @optional() shuriken: Weapon | undefined,\n  ) {\n    this.katana = katana;\n    this.shuriken = shuriken;\n  }\n}\n\nconst container: Container = new Container();\ncontainer.bind<Weapon>('Katana').to(Katana);\n\ncontainer.bind(Ninja).toSelf();\n\n// Returns a \"Ninja\" instance with a \"Katana\" katana property and undefined shuriken property.\nconst ninja: Ninja = container.get(Ninja);"},646:function(e){e.exports="interface Weapon {\n  damage: number;\n}\n\nexport class Katana implements Weapon {\n  #damage: number = 10;\n\n  public get damage(): number {\n    return this.#damage;\n  }\n\n  @postConstruct()\n  public improve(): void {\n    this.#damage += 2;\n  }\n}\n\nconst container: Container = new Container();\ncontainer.bind<Weapon>('Weapon').to(Katana);\n\n// Katana.damage is 12\nconst katana: Weapon = container.get<Weapon>('Weapon');"},8708:function(e){e.exports="interface Weapon {\n  damage: number;\n}\n\nclass Katana implements Weapon {\n  readonly #damage: number = 10;\n\n  public get damage(): number {\n    return this.#damage;\n  }\n\n  @preDestroy()\n  public onDeactivation(): void {\n    console.log(`Deactivating weapon with damage ${this.damage.toString()}`);\n  }\n}\n\nconst container: Container = new Container();\n\ncontainer.bind<Weapon>('Weapon').to(Katana).inSingletonScope();\n\ncontainer.get('Weapon');\n\nawait container.unbind('Weapon');"},1637:function(e){e.exports="@injectable()\nclass Ninja {\n  public katana: Weapon;\n  public shuriken: Weapon;\n  constructor(\n    @inject('Weapon') @tagged('weaponKind', 'melee') katana: Weapon,\n    @inject('Weapon') @tagged('weaponKind', 'ranged') shuriken: Weapon,\n  ) {\n    this.katana = katana;\n    this.shuriken = shuriken;\n  }\n}\n\nconst container: Container = new Container();\ncontainer.bind<Weapon>('Weapon').to(Katana).whenTagged('weaponKind', 'melee');\ncontainer\n  .bind<Weapon>('Weapon')\n  .to(Shuriken)\n  .whenTagged('weaponKind', 'ranged');\ncontainer.bind(Ninja).toSelf();\n\nconst ninja: Ninja = container.get(Ninja);"},3838:function(e){e.exports="import { Container, injectable, unmanaged } from 'inversify';\n\n@injectable()\nclass Base {\n  public prop: string;\n  constructor(@unmanaged() arg: string) {\n    this.prop = arg;\n  }\n}\n\n@injectable()\nclass Derived extends Base {\n  constructor() {\n    super('inherited-value');\n  }\n}\n\nconst container: Container = new Container();\n\ncontainer.bind(Derived).toSelf();\n\nconst derived: Derived = container.get(Derived);\n\n// Returns 'inherited-value'\nconst derivedProp: string = derived.prop;"}}]);