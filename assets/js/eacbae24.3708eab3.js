"use strict";(self.webpackChunk_inversifyjs_inversify_docs_site=self.webpackChunk_inversifyjs_inversify_docs_site||[]).push([["773"],{1241:function(n,e,i){i.r(e),i.d(e,{frontMatter:()=>j,toc:()=>w,default:()=>W,metadata:()=>a,assets:()=>y,contentTitle:()=>v});var a=JSON.parse('{"id":"api/container","title":"Container","description":"The InversifyJS container is where dependencies are first configured through binding and, possibly later, reconfigured and removed. The container can be worked on directly in this regard or container modules can be utilized.","source":"@site/versioned_docs/version-7.x/api/container.mdx","sourceDirName":"api","slug":"/api/container","permalink":"/docs/api/container","draft":false,"unlisted":false,"tags":[],"version":"7.x","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Container"},"sidebar":"tutorialSidebar","previous":{"title":"Binding Syntax","permalink":"/docs/api/binding-syntax"},"next":{"title":"Container Module","permalink":"/docs/api/container-module"}}'),o=i(4076),t=i(9221),r=i(7784),s=i(9270),d=i(2698),l=i(6458),c=i(6239),h=i(1240),u=i(2131),p=i(2382),g=i(535),b=i(5281),x=i(8978),f=i(7209),m=i(7419);let j={sidebar_position:2,title:"Container"},v="Container",y={},w=[{value:"Container Options",id:"container-options",level:2},{value:"autobind",id:"autobind",level:3},{value:"parent",id:"parent",level:3},{value:"defaultScope",id:"defaultscope",level:3},{value:"bind",id:"bind",level:2},{value:"get",id:"get",level:2},{value:"getAsync",id:"getasync",level:2},{value:"getAll",id:"getall",level:2},{value:"getAllAsync",id:"getallasync",level:2},{value:"isBound",id:"isbound",level:2},{value:"isCurrentBound",id:"iscurrentbound",level:2},{value:"load",id:"load",level:2},{value:"loadSync",id:"loadsync",level:2},{value:"onActivation",id:"onactivation",level:2},{value:"onDeactivation",id:"ondeactivation",level:2},{value:"rebind",id:"rebind",level:2},{value:"rebindSync",id:"rebindsync",level:2},{value:"register",id:"register",level:2},{value:"restore",id:"restore",level:2},{value:"snapshot",id:"snapshot",level:2},{value:"unbind",id:"unbind",level:2},{value:"Example: Unbind a binding by its identifier",id:"example-unbind-a-binding-by-its-identifier",level:3},{value:"unbindAll",id:"unbindall",level:2},{value:"unbindSync",id:"unbindsync",level:2},{value:"unload",id:"unload",level:2},{value:"unloadSync",id:"unloadsync",level:2},{value:"GetOptions",id:"getoptions",level:2},{value:"OptionalGetOptions",id:"optionalgetoptions",level:2},{value:"IsBoundOptions",id:"isboundoptions",level:2},{value:"GetAllOptions",id:"getalloptions",level:2}];function S(n){let e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.a)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"container",children:"Container"})}),"\n",(0,o.jsxs)(e.p,{children:["The InversifyJS container is where dependencies are first configured through binding and, possibly later, reconfigured and removed. The container can be worked on directly in this regard or container modules can be utilized.\nYou can query the configuration and resolve configured dependencies with the ",(0,o.jsx)(e.code,{children:"get"})," methods.\nYou can react to resolutions with container activation handlers and unbinding with container deactivation handlers.\nYou can create container hierarchies where container ascendants can supply the dependencies for descendants.\nFor testing, state can be saved as a snapshot on a stack and later restored."]}),"\n",(0,o.jsx)(e.h2,{id:"container-options",children:"Container Options"}),"\n",(0,o.jsx)(e.p,{children:"Container options can be passed to the Container constructor, and defaults will be provided if you do not or if you do but omit an option.\nOptions can be changed after construction and will be shared by child containers created from the Container if you do not provide options for them."}),"\n",(0,o.jsx)(e.h3,{id:"autobind",children:"autobind"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"autobind?: true;\n"})}),"\n",(0,o.jsx)(e.p,{children:"Option to automatically bind unbound class services to themselves. Whenever an instance is resolved, the container attempts to add a binding if no binding is found for the requested service."}),"\n",(0,o.jsx)(e.h3,{id:"parent",children:"parent"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"parent?: Container | undefined;\n"})}),"\n",(0,o.jsxs)(e.p,{children:["The parent container, if any. Refer to the ",(0,o.jsx)(e.a,{href:"/docs/fundamentals/di-hierarchy",children:"container hierarchy docs"})," for more information."]}),"\n",(0,o.jsx)(e.h3,{id:"defaultscope",children:"defaultScope"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"defaultScope?: BindingScope | undefined;\n"})}),"\n",(0,o.jsx)(e.p,{children:"The default scope for bindings."}),"\n",(0,o.jsx)(e.h2,{id:"bind",children:"bind"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"bind<T>(serviceIdentifier: ServiceIdentifier<T>): BindToFluentSyntax<T>\n"})}),"\n",(0,o.jsx)(e.p,{children:"Sets a new binding."}),"\n",(0,o.jsx)(e.admonition,{type:"info",children:(0,o.jsxs)(e.p,{children:["Unless specified otherwise, binding scopes are ",(0,o.jsx)(e.a,{href:"/docs/fundamentals/binding#transient",children:"transient"})," by default."]})}),"\n",(0,o.jsx)(e.h2,{id:"get",children:"get"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"get<T>(serviceIdentifier: ServiceIdentifier<T>, options: OptionalGetOptions): T | undefined;\nget<T>(serviceIdentifier: ServiceIdentifier<T>, options?: GetOptions): T;\n"})}),"\n",(0,o.jsx)(e.p,{children:"Resolves a dependency by its runtime identifier. The runtime identifier must be associated with only one binding and the binding must be synchronously resolved, otherwise an error is thrown."}),"\n",(0,o.jsx)(m.Z,{language:"ts",children:l}),"\n",(0,o.jsx)(e.h2,{id:"getasync",children:"getAsync"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"getAsync<T>(serviceIdentifier: ServiceIdentifier<T>, options: OptionalGetOptions): Promise<T | undefined>;\ngetAsync<T>(serviceIdentifier: ServiceIdentifier<T>, options?: GetOptions): Promise<T>;\n"})}),"\n",(0,o.jsx)(e.p,{children:"Resolves a dependency by its runtime identifier. The runtime identifier must be associated with only one binding, otherwise an error is thrown."}),"\n",(0,o.jsx)(m.Z,{language:"ts",children:d}),"\n",(0,o.jsx)(e.h2,{id:"getall",children:"getAll"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"getAll<T>(serviceIdentifier: ServiceIdentifier<T>, options?: GetAllOptions): T[];\n"})}),"\n",(0,o.jsx)(e.p,{children:"Get all available bindings for a given identifier. All the bindings must be synchronously resolved, otherwise an error is thrown:"}),"\n",(0,o.jsx)(m.Z,{language:"ts",children:r}),"\n",(0,o.jsx)(e.h2,{id:"getallasync",children:"getAllAsync"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"getAllAsync<T>(serviceIdentifier: ServiceIdentifier<T>, options?: GetAllOptions): Promise<T[]>\n"})}),"\n",(0,o.jsx)(e.p,{children:"Get all available bindings for a given identifier:"}),"\n",(0,o.jsx)(m.Z,{language:"ts",children:s}),"\n",(0,o.jsx)(e.h2,{id:"isbound",children:"isBound"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"isBound(serviceIdentifier: ServiceIdentifier<unknown>, options?: IsBoundOptions): boolean;\n"})}),"\n",(0,o.jsxs)(e.p,{children:["You can use the ",(0,o.jsx)(e.code,{children:"isBound"})," method to check if there are registered bindings for a given service identifier."]}),"\n",(0,o.jsx)(m.Z,{language:"ts",children:c}),"\n",(0,o.jsx)(e.h2,{id:"iscurrentbound",children:"isCurrentBound"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"isCurrentBound(serviceIdentifier: ServiceIdentifier<unknown>, options?: IsBoundOptions): boolean;\n"})}),"\n",(0,o.jsxs)(e.p,{children:["You can use the ",(0,o.jsx)(e.code,{children:"isCurrentBound"})," method to check if there are registered bindings for a given service identifier only in the current container."]}),"\n",(0,o.jsx)(m.Z,{language:"ts",children:h}),"\n",(0,o.jsx)(e.h2,{id:"load",children:"load"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"load(...modules: ContainerModule[]): Promise<void>;\n"})}),"\n",(0,o.jsxs)(e.p,{children:["Calls the registration method of each module. See ",(0,o.jsx)(e.a,{href:"/docs/api/container-module",children:"ContainerModule API docs"}),"."]}),"\n",(0,o.jsx)(e.h2,{id:"loadsync",children:"loadSync"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"loadSync(...modules: ContainerModule[]): void;\n"})}),"\n",(0,o.jsxs)(e.p,{children:["Synchronous version of ",(0,o.jsx)(e.code,{children:"load"}),". Calls the registration method of each module. Will throw an error if any module loading would be asynchronous. See ",(0,o.jsx)(e.a,{href:"/docs/api/container-module",children:"ContainerModule API docs"}),"."]}),"\n",(0,o.jsx)(e.h2,{id:"onactivation",children:"onActivation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"onActivation<T>(serviceIdentifier: ServiceIdentifier<T>, onActivation: BindingActivation<T>): void;\n"})}),"\n",(0,o.jsx)(e.p,{children:"Adds an activation handler for all services associated to the service identifier."}),"\n",(0,o.jsx)(m.Z,{language:"ts",children:u}),"\n",(0,o.jsx)(e.h2,{id:"ondeactivation",children:"onDeactivation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"onDeactivation<T>(serviceIdentifier: ServiceIdentifier<T>, onDeactivation: BindingDeactivation<T>): void;\n"})}),"\n",(0,o.jsx)(e.p,{children:"Adds a deactivation handler for a service identifier."}),"\n",(0,o.jsx)(m.Z,{language:"ts",children:p}),"\n",(0,o.jsx)(e.h2,{id:"rebind",children:"rebind"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"async rebind<T>(serviceIdentifier: ServiceIdentifier<T>): Promise<BindToFluentSyntax<T>>;\n"})}),"\n",(0,o.jsxs)(e.p,{children:["Convenience method that unbinds a service identifier and then creates a new binding for it. This is equivalent to calling ",(0,o.jsx)(e.code,{children:"await container.unbind(serviceId)"})," followed by ",(0,o.jsx)(e.code,{children:"container.bind(serviceId)"}),", but in a single method. Returns a binding builder to continue configuring the new binding."]}),"\n",(0,o.jsx)(m.Z,{language:"ts",children:x}),"\n",(0,o.jsx)(e.h2,{id:"rebindsync",children:"rebindSync"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"rebindSync<T>(serviceIdentifier: ServiceIdentifier<T>): BindToFluentSyntax<T>;\n"})}),"\n",(0,o.jsxs)(e.p,{children:["Synchronous version of ",(0,o.jsx)(e.code,{children:"rebind"}),". Unbinds a service identifier synchronously and then creates a new binding for it. Will throw an error if the unbind operation would be asynchronous. Returns a binding builder to continue configuring the new binding."]}),"\n",(0,o.jsx)(m.Z,{language:"ts",children:f}),"\n",(0,o.jsx)(e.h2,{id:"register",children:"register"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"register(pluginConstructor: Newable): void;\n"})}),"\n",(0,o.jsxs)(e.p,{children:["Registers a plugin to extend the container's functionality. The plugin must extend the ",(0,o.jsx)(e.code,{children:"Plugin"})," class from ",(0,o.jsx)(e.code,{children:"@inversifyjs/plugin"})," and respect its constructor signature. Refer to the ",(0,o.jsx)(e.a,{href:"/docs/fundamentals/plugins",children:"plugin docs"})," for more information."]}),"\n",(0,o.jsx)(e.h2,{id:"restore",children:"restore"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"restore(): void;\n"})}),"\n",(0,o.jsxs)(e.p,{children:["Restore container state to last snapshot. Refer to the ",(0,o.jsx)(e.a,{href:"/docs/fundamentals/snapshot",children:"docs"})," for more information."]}),"\n",(0,o.jsx)(e.h2,{id:"snapshot",children:"snapshot"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"snapshot(): void;\n"})}),"\n",(0,o.jsxs)(e.p,{children:["Save the state of the container to be later restored with the restore method. Refer to the ",(0,o.jsx)(e.a,{href:"/docs/fundamentals/snapshot",children:"docs"})," for more information."]}),"\n",(0,o.jsx)(e.h2,{id:"unbind",children:"unbind"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"unbind(identifier: BindingIdentifier | ServiceIdentifier): Promise<void>;\n"})}),"\n",(0,o.jsx)(e.p,{children:"Removes bindings from the container. When passed:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"A service identifier: removes all bindings bound to that service identifier"}),"\n",(0,o.jsx)(e.li,{children:"A binding identifier: removes the specific binding associated with that identifier"}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:["This will result in the ",(0,o.jsx)(e.a,{href:"/docs/fundamentals/lifecycle/deactivation",children:"deactivation process"}),"."]}),"\n",(0,o.jsx)(e.h3,{id:"example-unbind-a-binding-by-its-identifier",children:"Example: Unbind a binding by its identifier"}),"\n",(0,o.jsx)(m.Z,{language:"ts",children:g}),"\n",(0,o.jsx)(e.h2,{id:"unbindall",children:"unbindAll"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"unbindAll(): Promise<void>;\n"})}),"\n",(0,o.jsxs)(e.p,{children:["Remove all bindings binded in this container.  This will result in the ",(0,o.jsx)(e.a,{href:"/docs/fundamentals/lifecycle/deactivation",children:"deactivation process"}),"."]}),"\n",(0,o.jsx)(e.h2,{id:"unbindsync",children:"unbindSync"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"unbindSync(identifier: BindingIdentifier | ServiceIdentifier): void;\n"})}),"\n",(0,o.jsxs)(e.p,{children:["Removes bindings from the container synchronously. This method works like ",(0,o.jsx)(e.code,{children:"unbind"})," but does not return a Promise. If the unbinding operation would be asynchronous (e.g., due to deactivation handlers), it will throw an error. Use this method when you know the operation won't involve async deactivations."]}),"\n",(0,o.jsx)(m.Z,{language:"ts",children:b}),"\n",(0,o.jsx)(e.h2,{id:"unload",children:"unload"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"unload(...modules: ContainerModule[]): Promise<void>;\n"})}),"\n",(0,o.jsxs)(e.p,{children:["Removes bindings and handlers added by the modules. This will result in the ",(0,o.jsx)(e.a,{href:"/docs/fundamentals/lifecycle/deactivation",children:"deactivation process"}),".\nSee ",(0,o.jsx)(e.a,{href:"/docs/api/container-module",children:"ContainerModule API docs"}),"."]}),"\n",(0,o.jsx)(e.h2,{id:"unloadsync",children:"unloadSync"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"unloadSync(...modules: ContainerModule[]): void;\n"})}),"\n",(0,o.jsxs)(e.p,{children:["Synchronous version of ",(0,o.jsx)(e.code,{children:"unload"}),". Removes bindings and handlers added by the modules. Will throw an error if any module unloading would be asynchronous. This will result in the ",(0,o.jsx)(e.a,{href:"/docs/fundamentals/lifecycle/deactivation",children:"deactivation process"}),".\nSee ",(0,o.jsx)(e.a,{href:"/docs/api/container-module",children:"ContainerModule API docs"}),"."]}),"\n",(0,o.jsx)(e.h2,{id:"getoptions",children:"GetOptions"}),"\n",(0,o.jsxs)(e.p,{children:["Options that can be passed to the ",(0,o.jsx)(e.code,{children:"get"}),", ",(0,o.jsx)(e.code,{children:"getAll"}),", ",(0,o.jsx)(e.code,{children:"getAsync"}),", and ",(0,o.jsx)(e.code,{children:"getAllAsync"})," methods."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"interface GetOptions {\n  autobind?: boolean;\n  name?: MetadataName;\n  optional?: boolean;\n  tag?: GetOptionsTagConstraint;\n}\n"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"autobind"})," (boolean): Option to automatically bind unbound class services to themselves."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"name"})," (MetadataName): The name metadata to match bindings."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"optional"})," (boolean): If true, the method will return ",(0,o.jsx)(e.code,{children:"undefined"})," or empty array if no binding is found."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"tag"})," (GetOptionsTagConstraint): The tag metadata to match bindings."]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"optionalgetoptions",children:"OptionalGetOptions"}),"\n",(0,o.jsxs)(e.p,{children:["Options that can be passed to the ",(0,o.jsx)(e.code,{children:"get"})," and ",(0,o.jsx)(e.code,{children:"getAsync"})," methods when the result is optional."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"interface OptionalGetOptions extends GetOptions {\n  optional: true;\n}\n"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"optional"})," (true): Indicates that the result is optional and the method will return ",(0,o.jsx)(e.code,{children:"undefined"})," if no binding is found."]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"isboundoptions",children:"IsBoundOptions"}),"\n",(0,o.jsxs)(e.p,{children:["Options that can be passed to the ",(0,o.jsx)(e.code,{children:"isBound"})," and ",(0,o.jsx)(e.code,{children:"isCurrentBound"})," methods."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"interface IsBoundOptions {\n  name?: MetadataName;\n  tag?: GetOptionsTagConstraint;\n}\n"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"name"})," (MetadataName): The name metadata to match bindings."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"tag"})," (GetOptionsTagConstraint): The tag metadata to match bindings."]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"getalloptions",children:"GetAllOptions"}),"\n",(0,o.jsxs)(e.p,{children:["Options that can be passed to the ",(0,o.jsx)(e.code,{children:"getAll"})," and ",(0,o.jsx)(e.code,{children:"getAllAsync"})," methods."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"interface GetAllOptions extends GetOptions {\n  chained?: boolean;\n}\n"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"chained"})," (boolean): Option to enable chained resolution across container hierarchies. Refer to the ",(0,o.jsx)(e.a,{href:"/docs/fundamentals/di-hierarchy#chained-resolution-mode",children:"docs"})," for more information."]}),"\n"]})]})}function W(n={}){let{wrapper:e}={...(0,t.a)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(S,{...n})}):S(n)}},6458:function(n){n.exports="const container: Container = new Container();\ncontainer.bind<Weapon>('Weapon').to(Katana);\n\nconst katana: Weapon = container.get<Weapon>('Weapon');"},7784:function(n){n.exports="const container: Container = new Container();\ncontainer.bind<Weapon>('Weapon').to(Katana);\ncontainer.bind<Weapon>('Weapon').to(Shuriken);\n\n// returns Weapon[] with both Katana and Shuriken instances\nconst weapons: Weapon[] = container.getAll<Weapon>('Weapon');"},9270:function(n){n.exports="const container: Container = new Container();\ncontainer.bind<Weapon>('Weapon').toDynamicValue(async () => new Katana());\ncontainer.bind<Weapon>('Weapon').to(Shuriken);\n\nconst weapons: Promise<Weapon[]> = container.getAllAsync<Weapon>('Weapon');"},2698:function(n){n.exports="async function buildLevel1(): Promise<Level1> {\n  return new Level1();\n}\n\nconst container: Container = new Container();\ncontainer\n  .bind('Level1')\n  .toDynamicValue(async (): Promise<Level1> => buildLevel1());\n\nconst level1: Promise<Level1> = container.getAsync<Level1>('Level1');"},6239:function(n){n.exports="interface Warrior {\n  kind: string;\n}\n\nconst katanaSymbol: symbol = Symbol.for('Katana');\nconst warriorSymbol: symbol = Symbol.for('Warrior');\n\n@injectable()\nclass Ninja implements Warrior {\n  public readonly kind: string = 'ninja';\n}\n\n@injectable()\nclass Katana {}\n\nconst container: Container = new Container();\ncontainer.bind<Warrior>(Ninja).to(Ninja);\ncontainer.bind<Warrior>(warriorSymbol).to(Ninja);\n\n// returns true\nconst isNinjaBound: boolean = container.isBound(Ninja);\n// returns true\nconst isWarriorSymbolBound: boolean = container.isBound(warriorSymbol);\n// returns false\nconst isKatanaBound: boolean = container.isBound(Katana);\n// returns false\nconst isKatanaSymbolBound: boolean = container.isBound(katanaSymbol);"},1240:function(n){n.exports="interface Warrior {\n  kind: string;\n}\n\nconst katanaSymbol: symbol = Symbol.for('Katana');\nconst warriorSymbol: symbol = Symbol.for('Warrior');\n\n@injectable()\nclass Ninja implements Warrior {\n  public readonly kind: string = 'ninja';\n}\n\n@injectable()\nclass Katana {}\n\nconst container: Container = new Container();\ncontainer.bind<Warrior>(Ninja).to(Ninja);\ncontainer.bind<Warrior>(warriorSymbol).to(Ninja);\n\nconst containerChild: Container = new Container({ parent: container });\n\ncontainerChild.bind<Katana>(Katana).to(Katana);\ncontainerChild.bind<Katana>(katanaSymbol).to(Katana);\n\n// returns false\nconst isNinjaBound: boolean = containerChild.isCurrentBound(Ninja);\n// returns false\nconst isWarriorSymbolBound: boolean =\n  containerChild.isCurrentBound(warriorSymbol);\n// returns true\nconst isKatanaBound: boolean = containerChild.isCurrentBound(Katana);\n// returns true\nconst isKatanaSymbolBound: boolean =\n  containerChild.isCurrentBound(katanaSymbol);"},2131:function(n){n.exports="interface Weapon {\n  damage: number;\n}\n\nexport class Katana implements Weapon {\n  #damage: number = 10;\n\n  public get damage(): number {\n    return this.#damage;\n  }\n\n  public improve(): void {\n    this.#damage += 2;\n  }\n}\n\nconst container: Container = new Container();\ncontainer.bind<Weapon>('Weapon').to(Katana);\ncontainer.onActivation(\n  'Weapon',\n  (_context: ResolutionContext, katana: Katana): Katana | Promise<Katana> => {\n    katana.improve();\n\n    return katana;\n  },\n);\n\n// Katana.damage is 12\nconst katana: Weapon = container.get<Weapon>('Weapon');"},2382:function(n){n.exports="interface Weapon {\n  damage: number;\n}\n\nclass Katana implements Weapon {\n  readonly #damage: number = 10;\n\n  public get damage(): number {\n    return this.#damage;\n  }\n}\n\nconst container: Container = new Container();\n\ncontainer.bind<Weapon>('Weapon').to(Katana).inSingletonScope();\n\ncontainer.get('Weapon');\n\ncontainer.onDeactivation('Weapon', (weapon: Weapon): void | Promise<void> => {\n  console.log(`Deactivating weapon with damage ${weapon.damage.toString()}`);\n});\n\nawait container.unbind('Weapon');"},8978:function(n){n.exports="const container: Container = new Container();\n\n// Create initial binding\ncontainer.bind<Weapon>('Weapon').to(Katana);\n\n// Get instance of Katana\nconst katana: Weapon = container.get<Weapon>('Weapon');\nconsole.log(katana.damage); // 10\n\n// Rebind asynchronously to Shuriken\nasync function rebindWeapon() {\n  // First unbind the existing service\n  await container.unbind('Weapon');\n\n  // Then bind to the new service\n  container.bind<Weapon>('Weapon').to(Shuriken);\n\n  // Get instance of Shuriken\n  const shuriken: Weapon = container.get<Weapon>('Weapon');\n  console.log(shuriken.damage); // 8\n}\n\n// Call the async function\nvoid rebindWeapon();"},7209:function(n){n.exports="const container: Container = new Container();\n\n// Create initial binding\ncontainer.bind<Weapon>('Weapon').to(Katana);\n\n// Get instance of Katana\nconst katana: Weapon = container.get<Weapon>('Weapon');\nconsole.log(katana.damage); // 10\n\n// Rebind synchronously to Shuriken\n// This returns a BindToFluentSyntax to continue configuring the binding\ncontainer.rebindSync<Weapon>('Weapon').to(Shuriken);\n\n// Get instance of Shuriken\nconst shuriken: Weapon = container.get<Weapon>('Weapon');\nconsole.log(shuriken.damage);"},535:function(n){n.exports="const bindingIdentifier: BindingIdentifier = container\n    .bind('MyService')\n    .to(MyServiceImpl)\n    .getIdentifier();\n\n  // Later, unbind just this specific binding\n  await container.unbind(bindingIdentifier);"},5281:function(n){n.exports="const container: Container = new Container();\n\n// Create a binding\ncontainer.bind<Weapon>('Weapon').to(Katana);\n\n// Check if it's bound\nconsole.log(container.isBound('Weapon')); // true\n\n// Synchronously unbind the service\ncontainer.unbindSync('Weapon');\n\n// Verify it's unbound\nconsole.log(container.isBound('Weapon'));"}}]);